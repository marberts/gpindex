
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # These tests are slow and not usually needed
> # They really work the core computational functions
> # Should return all TRUE
> 
> library(gpindex)
> 
> set.seed(4132)
> x <- rlnorm(15)
> xna <- replace(rlnorm(15), c(4, 12), NA)
> w <- runif(15)
> a <- runif(15, 0, 5)
> b <- rlnorm(15)
> 
> # Simple implementations
> gmean <- function(x, w, r) {
+   if (r != 0) {
+     (weighted.mean(x^r, w, na.rm = TRUE))^(1 / r)
+   } else {
+     exp(weighted.mean(log(x), w, na.rm = TRUE))
+   }
+ }
> 
> nmean <- function(x, w1, w2, r1, r2, t) {
+   m1 <- gmean(x, w1, r2[1])
+   m2 <- gmean(x, w2, r2[2])
+   gmean(c(m1, m2), t, r1)
+ }
> 
> lmean <- function(x, w, r) {
+   w <- if (missing(w)) x^(r - 1) else w * x^(r - 1)
+   weighted.mean(x, w, na.rm = TRUE)
+ }
> 
> emean <- function(a, b, r, s) {
+   if (r == 0 && s == 0) {
+     sqrt(a * b)
+   } else if (r == 0) {
+     ((a^s - b^s) / log(a / b) / s)^(1 / s)
+   } else if (s == 0) {
+     ((a^r - b^r) / log(a / b) / r)^(1 / r)
+   } else if (r == s) {
+     exp((a^r * log(a) - b^r * log(b)) / (a^r - b^r) - 1 / r)
+   } else {
+     ((a^s - b^s) / (a^r - b^r) * r / s)^(1 / (s - r))
+   }
+ }
> 
> grid1 <- seq(-10, 10, by = 0.25)
> grid2 <- expand.grid(a = seq(-10, 10, by = 0.25), b = seq(-10, 10, by = 0.25))
> 
> # Generalized mean
> # Unweighted case
> all(vapply(grid1, function(r) {
+   all.equal(generalized_mean(r)(x), gmean(x, r = r))
+ }, logical(1)))
[1] TRUE
> 
> all(vapply(grid1, function(r) {
+   all.equal(generalized_mean(r)(xna, na.rm = TRUE), gmean(xna, r = r))
+ }, logical(1)))
[1] TRUE
> 
> # Weighted case
> all(vapply(grid1, function(r) {
+   all.equal(generalized_mean(r)(x, w), gmean(x, w, r))
+ }, logical(1)))
[1] TRUE
> 
> all(vapply(grid1, function(r) {
+   all.equal(generalized_mean(r)(xna, w, na.rm = TRUE), gmean(xna, w, r))
+ }, logical(1)))
[1] TRUE
> 
> # Lehmer mean
> # Unweighted case
> all(vapply(grid1, function(r) {
+   all.equal(lehmer_mean(r)(x), lmean(x, r = r))
+ }, logical(1)))
[1] TRUE
> 
> all(vapply(grid1, function(r) {
+   all.equal(lehmer_mean(r)(xna, na.rm = TRUE), lmean(xna, r = r))
+ }, logical(1)))
[1] TRUE
> 
> # Weighted case
> all(vapply(grid1, function(r) {
+   all.equal(lehmer_mean(r)(x, w), lmean(x, w, r))
+ }, logical(1)))
[1] TRUE
> 
> all(vapply(grid1, function(r) {
+   all.equal(lehmer_mean(r)(xna, w, na.rm = TRUE), lmean(xna, w, r))
+ }, logical(1)))
[1] TRUE
> 
> # Extended mean
> all(apply(grid2, 1, function(p) {
+   all.equal(extended_mean(p[1], p[2])(a, b),
+             emean(a, b, p[1], p[2]),
+             check.names = FALSE)
+ }))
[1] TRUE
> 
> all(apply(grid2, 1, function(p) {
+   all.equal(extended_mean(p[1], p[2])(a, b),
+             emean(a, b, p[2], p[1]),
+             check.names = FALSE)
+ }))
[1] TRUE
> 
> # Transmute weights
> # Unweighted case
> all(apply(grid2, 1, function(p) {
+   all.equal(generalized_mean(p[1])(x),
+             generalized_mean(p[2])(x, transmute_weights(p[1], p[2])(x)),
+             check.names = FALSE)
+ }))
[1] TRUE
> all(apply(grid2, 1, function(p) {
+   all.equal(generalized_mean(p[1])(xna, na.rm = TRUE),
+             generalized_mean(p[2])(xna, transmute_weights(p[1], p[2])(xna), na.rm = TRUE),
+             check.names = FALSE)
+ }))
[1] TRUE
> # Weighted case
> all(apply(grid2, 1, function(p) {
+   all.equal(generalized_mean(p[1])(x, w),
+             generalized_mean(p[2])(x, transmute_weights(p[1], p[2])(x, w)),
+             check.names = FALSE)
+ }))
[1] TRUE
> all(apply(grid2, 1, function(p) {
+   all.equal(generalized_mean(p[1])(xna, w, na.rm = TRUE),
+             generalized_mean(p[2])(xna, transmute_weights(p[1], p[2])(xna, w), na.rm = TRUE),
+             check.names = FALSE)
+ }))
[1] TRUE
> 
> # Factor weights
> # Unweighted case
> all(vapply(grid1,
+            function(r) {
+              all.equal(generalized_mean(r)(x * a),
+                        generalized_mean(r)(x) * generalized_mean(r)(a, factor_weights(r)(x)))
+            },
+            logical(1)))
[1] TRUE
> all(vapply(grid1,
+            function(r) {
+              all.equal(generalized_mean(r)(xna * a, na.rm = TRUE),
+                        generalized_mean(r)(xna, na.rm = TRUE) *
+                          generalized_mean(r)(a, factor_weights(r)(xna), na.rm = TRUE))
+            },
+            logical(1)))
[1] TRUE
> # Weighted case
> all(vapply(grid1,
+            function(r) {
+              all.equal(generalized_mean(r)(x * a, w),
+                        generalized_mean(r)(x, w) * generalized_mean(r)(a, factor_weights(r)(x, w)))
+            },
+            logical(1)))
[1] TRUE
> all(vapply(grid1,
+            function(r) {
+              all.equal(generalized_mean(r)(xna * a, w, na.rm = TRUE),
+                        generalized_mean(r)(xna, w, na.rm = TRUE) *
+                          generalized_mean(r)(a, factor_weights(r)(xna, w), na.rm = TRUE))
+            },
+            logical(1)))
[1] TRUE
> # Nested mean
> # Doing the checks over a grid is too big, some make some random
> # parameters instead
> r <- runif(1e3, -10, 10)
> r2 <- matrix(c(runif(1e3, -10, 10), runif(1e3, -10, 10)), nrow = 2)
> t <- matrix(c(runif(1e3), runif(1e3)), nrow = 2)
> s <- runif(1e3, -10, 10)
> # No NAs
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(x, a, b),
+                        nmean(x, a, b, r[i], r2[, i], t[, i]))
+            }, logical(1)))
[1] TRUE
> 
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(x, a, b),
+                        gmean(x, nested_transmute(r[i], r2[, i], s[i], t[, i])(x, a, b), s[i]))
+            }, logical(1)))
[1] TRUE
> 
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(x, a, b),
+                        gmean(x, nested_transmute2(r[i], r2[, i], s[i], t[, i])(x, a, b), s[i]))
+            }, logical(1)))
[1] TRUE
> # NAs in x
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(xna, a, b, na.rm = TRUE),
+                        nmean(xna, a, b, r[i], r2[, i], t[, i]))
+            }, logical(1)))
[1] TRUE
> 
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(xna, a, b, na.rm = TRUE),
+                        gmean(xna, nested_transmute(r[i], r2[, i], s[i], t[, i])(xna, a, b), s[i]))
+            }, logical(1)))
[1] TRUE
> 
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(xna, a, b, na.rm = TRUE),
+                        gmean(xna, nested_transmute2(r[i], r2[, i], s[i], t[, i])(xna, a, b), s[i]))
+            }, logical(1)))
[1] TRUE
> # NA weights
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(a, xna, b, na.rm = TRUE),
+                        generalized_mean(s[i])(a, nested_transmute(r[i], r2[, i], s[i], t[, i])(a, xna, b)))
+            }, logical(1)))
[1] TRUE
> 
> all(vapply(1:1e3,
+            function(i) {
+              all.equal(nested_mean(r[i], r2[, i], t[, i])(a, b, xna, na.rm = TRUE),
+                        generalized_mean(s[i])(a, nested_transmute2(r[i], r2[, i], s[i], t[, i])(a, b, xna)))
+            }, logical(1)))
[1] TRUE
> 
> proc.time()
   user  system elapsed 
 32.837   0.016  32.861 
