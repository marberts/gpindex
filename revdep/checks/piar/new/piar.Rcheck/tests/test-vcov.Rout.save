
R version 4.1.3 (2022-03-10) -- "One Push-Up"
Copyright (C) 2022 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> library(piar)
> library(gpindex)
> 
> set.seed(4321)
> 
> # Corner case
> vcov(aggregate(elemental_index(numeric(0)), aggregation_structure("a")),
+      matrix(1:10, ncol = 10))
     1
>
> vcov(aggregate(elemental_index(numeric(0)), aggregation_structure(1:5)),
+      matrix(runif(10), ncol = 10))
   1
1 NA
2 NA
3 NA
4 NA
> 
> # Toy example
> prices <- data.frame(rel = runif(24), 
+                      period = 1:3, 
+                      id = rep(letters[1:8], each = 3))
> 
> weights <- data.frame(l1 = rep(1, 8), 
+                       l2 = rep(c(11, 12), each = 4), 
+                       l3 = rep(c(111, 112, 121, 122), each = 2),
+                       l4 = letters[1:8],
+                       ew = round(1000 * runif(8)),
+                       dw = c(1, runif(6, 1, 10), 1))
> 
> epr <- with(prices, elemental_index(rel, period, id))
> pias <- with(weights, aggregation_structure(weights[1:4], ew * dw))
> index <- aggregate(epr, pias)
> 
> rw <- matrix(runif(8 * 25), 8)
> 
> #---- mse = FALSE case ----
> (covar <- vcov(index, rw * weights$ew, mse = FALSE))
              1            2            3
1   0.004973962 0.0030769489 8.529303e-03
11  0.021058698 0.0048189603 4.006912e-04
12  0.007144902 0.0034192194 1.040751e-02
111 0.006844730 0.0136284727 1.155123e-05
112 0.015339091 0.0067777089 1.849310e-03
121 0.004686600 0.0003418113 2.339665e-04
122 0.042732065 0.0128604028 2.104609e-03
> 
> # Variance for higher levels should agree with manual calculation
> # Period 1
> rws <- apply(rw * weights$ew, 2, scale_weights)
> all.equal(sum(crossprod(as.matrix(epr[, 1]), tcrossprod(sweep(rws, 1, rowMeans(rws))) / 25) * t(as.matrix(epr[, 1]))),
+           covar[1, 1]) # 0.004973962 according to svymean
[1] TRUE
> 
> # Period 2
> rws <- apply(rw * weights(update(pias, index, 1), TRUE) / weights$dw, 2, scale_weights)
> all.equal(sum(crossprod(as.matrix(epr[, 2]), tcrossprod(sweep(rws, 1, rowMeans(rws))) / 25) * t(as.matrix(epr[, 2]))),
+           covar[1, 2]) # 0.003076949 according to svymean
[1] TRUE
> 
> #---- mse = TRUE case ----
> (covar <- vcov(index, rw * weights$ew))
             1            2            3
1   0.02001844 0.0081531729 2.610145e-02
11  0.03798322 0.0106501335 4.046638e-04
12  0.01969343 0.0046231792 2.970839e-02
111 0.01889301 0.0341332553 2.956127e-05
112 0.01710266 0.0067874268 2.056151e-03
121 0.00473124 0.0003461105 2.358189e-04
122 0.11235358 0.0380862056 3.172872e-03
> 
> # Variance for higher levels should agree with manual calculation
> # Period 1
> rws <- apply(rw * weights$ew, 2, scale_weights)
> w <- weights(pias, ea_only = TRUE)
> all.equal(sum(crossprod(as.matrix(epr[, 1]), tcrossprod(sweep(rws, 1, scale_weights(w))) / 25) * t(as.matrix(epr[, 1]))),
+           covar[1, 1]) # 0.02001844 according to svymean
[1] TRUE
> 
> # Period 2
> rws <- apply(rw * weights(update(pias, index, 1), TRUE) / weights$dw, 2, scale_weights)
> all.equal(sum(crossprod(as.matrix(epr[, 2]), tcrossprod(sweep(rws, 1, scale_weights(weights(update(pias, index, 1), TRUE)))) / 25) * t(as.matrix(epr[, 2]))),
+           covar[1, 2]) # 0.008153173 according to svymean
[1] TRUE
> 
> #---- chained index ----
> (covar <- vcov(chain(index), rw * weights$ew))
             1            2            3
1   0.02001844 4.125957e-03 2.291649e-03
11  0.03798322 4.518025e-04 6.744137e-05
12  0.01969343 6.162671e-03 3.090134e-03
111 0.01889301 1.255677e-02 1.680672e-03
112 0.01710266 1.553791e-07 5.609677e-06
121 0.00473124 2.524740e-03 1.008371e-05
122 0.11235358 3.866889e-02 1.623303e-02
> 
> # Variance for higher levels should agree with manual calculation
> # Period 1
> rws <- apply(rw * weights$ew, 2, scale_weights)
> w <- weights(pias, ea_only = TRUE)
> all.equal(sum(crossprod(as.matrix(epr[, 1]), tcrossprod(sweep(rws, 1, scale_weights(w))) / 25) * t(as.matrix(epr[, 1]))),
+           covar[1, 1]) # 0.02001844 according to svymean
[1] TRUE
> 
> # Period 2
> epr <- chain(epr)
> all.equal(sum(crossprod(as.matrix(epr[, 2]), tcrossprod(sweep(rws, 1, scale_weights(w))) / 25) * t(as.matrix(epr[, 2]))),
+           covar[1, 2]) # 0.004125957 according to svymean
[1] TRUE
> 
> proc.time()
   user  system elapsed 
  0.450   0.164   0.483 
