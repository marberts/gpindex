
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #---- Tests for shadow_price() ----
> library(piar)
> 
> # Make an aggregation structure for the imputations
> pias <- with(
+   ms_weights, 
+   aggregation_structure(c(expand_classification(classification), list(business)),
+                         weight)
+ )
> 
> # Length 0 prices return a length 0 output of the same type
> shadow_price(integer(0), integer(0), integer(0), integer(0), pias)
integer(0)
> 
> # Imputing shadow prices does nothing
> (sp <- with(ms_prices, shadow_price(price, period, product, business, pias)))
 [1]  1.140000        NA  6.090000  6.230000  8.610000  6.400000  0.090000
 [8]  2.330000  6.660000  5.140000  6.940000  5.450000  8.103510 11.199233
[15]  8.324633  8.370000  2.860000  2.670000  1.870000  2.320000  1.821902
[22]  3.030000  1.590000  0.400000  2.190000  8.110000  5.260000  9.150000
[29]  8.310000  0.460000  1.387840  2.650000  3.050000  5.070000  1.810000
[36]  7.600000  2.010000  2.590000  9.920000  8.070000
> 
> all.equal(sp, with(ms_prices, shadow_price(sp, period, product, business, pias)))
[1] TRUE
> 
> # First period with missing values gives the same result as ignoring them
> # EPR without shadow prices
> epr <- with(
+   ms_prices, 
+   elemental_index(price_relative(price, period, product), period, business, na.rm = TRUE)
+ )
> # EPR with shadow prices
> epr2 <- with(
+   ms_prices, 
+   elemental_index(price_relative(sp, period, product), period, business, na.rm = TRUE)
+ )
> 
> all.equal(epr[c(1, 3:4), 1:3], epr2[c(1, 3:4), 1:3]) # B2 is imputed from above the EA level
[1] TRUE
> 
> all.equal(aggregate(epr, pias, na.rm = TRUE)[, 1:2], 
+           aggregate(epr2, pias, na.rm = TRUE)[, 1:2])
[1] TRUE
> 
> # No imputation should happen if the pias doesn't line up with the elemental aggregates
> # Append a '1' to each business label to make a garbage pias
> pias2 <- with(
+   ms_weights, 
+   aggregation_structure(c(expand_classification(classification), list(paste0(business, 1))), 
+                         weight)
+ )
> 
> all.equal(ms_prices$price,
+           with(ms_prices, shadow_price(price, period, product, business, pias2)))
[1] TRUE
> 
> # Jumbling prices does nothing
> set.seed(4321)
> 
> jumble <- sample(nrow(ms_prices))
> ms_prices <- ms_prices[jumble, ]
> all.equal(with(ms_prices, shadow_price(price, period, product, business, pias)),
+           sp[jumble])
[1] TRUE
> 
> proc.time()
   user  system elapsed 
  0.424   0.178   0.479 
