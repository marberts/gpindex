
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #---- Tests for aggregation_structure() and associated methods ----
> library(piar)
> 
> # Build an improper pias
> # Should give a warning about improper parent nodes
> aggregation_structure(list(1:2, c(3, 3), c(4, 5)))
[[1]]
[1] "1" "2"

[[2]]
[1] "3"

[[3]]
[1] "4" "5"

Warning message:
In aggregation_structure(list(1:2, c(3, 3), c(4, 5))) :
  some nodes in the price index aggregation structure have multiple parent nodes; the aggregation structure does not represent a nested hierarchy
> 
> # A real-ish example
> x1 <- c("1", "1", "1", "2")
> x2 <- c("11", "11", "12", "21")
> x3 <- c("111", "112", "121", "211")
> 
> # Test the print.pias() method
> (agg1 <- aggregation_structure(list(x1, x2, x3)))
[[1]]
[1] "1" "2"

[[2]]
[1] "11" "12" "21"

[[3]]
[1] "111" "112" "121" "211"

> 
> unclass(agg1)
$child
$child[[1]]
$child[[1]]$`11`
[1] 1 2

$child[[1]]$`12`
[1] 3

$child[[1]]$`21`
[1] 4


$child[[2]]
$child[[2]]$`1`
[1] 1 2

$child[[2]]$`2`
[1] 3



$parent
$parent[[1]]
111 112 121 211 
  1   1   2   3 

$parent[[2]]
11 12 21 
 1  1  2 


$levels
[1] "1"   "2"   "11"  "12"  "21"  "111" "112" "121" "211"

$eas
[1] "111" "112" "121" "211"

$weights
111 112 121 211 
  1   1   1   1 

$height
[1] 3

> 
> # Using expand classification should give the same result
> all.equal(agg1, aggregation_structure(expand_classification(x3)))
[1] TRUE
>
> # Coercion methods
> as.matrix(aggregation_structure(1))
     1
> 
> as.data.frame(aggregation_structure(1))
  ea weight
1  1      1
> 
> all.equal(agg1, 
+           with(as.data.frame(agg1), aggregation_structure(list(level1, level2, ea), weight)))
[1] TRUE
> 
> # 4-levels, out of order
> y1 <- c(1, 1, 1, 1, 1, 1)
> y2 <- c(11, 11, 11, 12, 12, 12)
> y3 <- c(111, 111, 112, 121, 122, 122)
> y4 <- c(1111, 1112, 1121, 1211, 1221, 1222)
> ord <- c(1, 6, 2, 4, 5, 3)
> agg2 <- aggregation_structure(list(y1[ord], y2[ord], y3[ord], y4[ord]), c(rep(1, 5), 2))
> 
> as.matrix(agg2)
         1111      1222      1112      1211      1221      1121
1   0.1428571 0.1428571 0.1428571 0.1428571 0.1428571 0.2857143
11  0.2500000 0.0000000 0.2500000 0.0000000 0.0000000 0.5000000
12  0.0000000 0.3333333 0.0000000 0.3333333 0.3333333 0.0000000
111 0.5000000 0.0000000 0.5000000 0.0000000 0.0000000 0.0000000
112 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 1.0000000
121 0.0000000 0.0000000 0.0000000 1.0000000 0.0000000 0.0000000
122 0.0000000 0.5000000 0.0000000 0.0000000 0.5000000 0.0000000
> 
> as.data.frame(agg2)
  level1 level2 level3   ea weight
1      1     11    111 1111      1
2      1     12    122 1222      1
3      1     11    111 1112      1
4      1     12    121 1211      1
5      1     12    122 1221      1
6      1     11    112 1121      2
> 
> # Calculate weights with the weights.pias() method
> weights(agg1)
[[1]]
1 2 
3 1 

[[2]]
11 12 21 
 2  1  1 

[[3]]
111 112 121 211 
  1   1   1   1 

> 
> weights(agg1, ea_only = TRUE)
111 112 121 211 
  1   1   1   1 
> 
> # Unequal weights
> weights(aggregation_structure(list(x1, x2, x3), 1:4))
[[1]]
1 2 
6 4 

[[2]]
11 12 21 
 3  3  4 

[[3]]
111 112 121 211 
  1   2   3   4 

> 
> weights(aggregation_structure(list(x1, x2, x3), c(NA, 2:4)))
[[1]]
 1  2 
NA  4 

[[2]]
11 12 21 
NA  3  4 

[[3]]
111 112 121 211 
 NA   2   3   4 

> 
> weights(aggregation_structure(list(x1, x2, x3), c(NA, 2:4)), na.rm = TRUE)
[[1]]
1 2 
5 4 

[[2]]
11 12 21 
 2  3  4 

[[3]]
111 112 121 211 
 NA   2   3   4 

> 
> # Update with the update.pias() method
> # Updating with a length-0 index should make the weights NA
> epr <- elemental_index(integer(0))
> index <- aggregate(epr, agg1)
> all.equal(update(agg1, index)[-5], agg1[-5])
[1] TRUE
> weights(agg1)
[[1]]
1 2 
3 1 

[[2]]
11 12 21 
 2  1  1 

[[3]]
111 112 121 211 
  1   1   1   1 

> weights(update(agg1, index))
[[1]]
 1  2 
NA NA 

[[2]]
11 12 21 
NA NA NA 

[[3]]
111 112 121 211 
 NA  NA  NA  NA 

> 
> # Updating with an index that doesn't line up with the pias introduces NA weights
> # These should carry up the aggregation structure
> epr <- elemental_index(1, ea = "111")
> index <- aggregate(epr, agg1)
> weights(update(agg1, index))
[[1]]
 1  2 
NA NA 

[[2]]
11 12 21 
NA NA NA 

[[3]]
111 112 121 211 
  1  NA  NA  NA 

> 
> # Accommodate a delimiter when expanding the classification by setting the width
> (agg2 <- aggregation_structure(expand_classification(c("1.1.1", "1.1.2", "1.2.1"), 
+                                                      c(2, 2, 1))))
[[1]]
[1] "1."

[[2]]
[1] "1.1." "1.2."

[[3]]
[1] "1.1.1" "1.1.2" "1.2.1"

> 
> unclass(agg2)
$child
$child[[1]]
$child[[1]]$`1.1.`
[1] 1 2

$child[[1]]$`1.2.`
[1] 3


$child[[2]]
$child[[2]]$`1.`
[1] 1 2



$parent
$parent[[1]]
1.1.1 1.1.2 1.2.1 
    1     1     2 

$parent[[2]]
1.1. 1.2. 
   1    1 


$levels
[1] "1."    "1.1."  "1.2."  "1.1.1" "1.1.2" "1.2.1"

$eas
[1] "1.1.1" "1.1.2" "1.2.1"

$weights
1.1.1 1.1.2 1.2.1 
    1     1     1 

$height
[1] 3

> 
> # Change start by setting the width
> (agg3 <- aggregation_structure(expand_classification(c("1.1.1", "1.1.2", "1.2.1"), 
+                                                      c(4, 1))))
[[1]]
[1] "1.1." "1.2."

[[2]]
[1] "1.1.1" "1.1.2" "1.2.1"

> 
> unclass(agg3)
$child
$child[[1]]
$child[[1]]$`1.1.`
[1] 1 2

$child[[1]]$`1.2.`
[1] 3



$parent
$parent[[1]]
1.1.1 1.1.2 1.2.1 
    1     1     2 


$levels
[1] "1.1."  "1.2."  "1.1.1" "1.1.2" "1.2.1"

$eas
[1] "1.1.1" "1.1.2" "1.2.1"

$weights
1.1.1 1.1.2 1.2.1 
    1     1     1 

$height
[1] 2

> 
> # Aggregation matrix
> as.matrix(agg3)
      1.1.1 1.1.2 1.2.1
1.1.    0.5   0.5     0
1.2.    0.0   0.0     1
> 
> as.matrix(aggregation_structure(1:3, 2))
  3
1 1
2 1
> 
> as.matrix(aggregation_structure(list(letters[c(2, 1, 3)]), 1:3))
     b a c
>
> proc.time()
   user  system elapsed 
  0.095   0.030   0.118 
