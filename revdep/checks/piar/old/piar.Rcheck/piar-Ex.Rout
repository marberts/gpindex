
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "piar"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('piar')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("aggregation-structure")
> ### * aggregation-structure
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregation_structure
> ### Title: Aggregation structure
> ### Aliases: aggregation_structure weights.pias update.pias as.matrix.pias
> ###   as.data.frame.pias expand_classification
> 
> ### ** Examples
> 
> # A simple example
> #            1
> #      |-----+-----|
> #      11          12
> #  |---+---|       |
> #  111     112     121
> 
> x1 <- c("1",   "1",   "1")
> x2 <- c("11",  "11",  "12")
> x3 <- c("111", "112", "121")
> 
> aggregation_structure(list(x1, x2, x3))
[[1]]
[1] "1"

[[2]]
[1] "11" "12"

[[3]]
[1] "111" "112" "121"

> 
> # The aggregation structure can also be made by expanding 'x3'
> 
> expand_classification(x3)
[[1]]
[1] "1" "1" "1"

[[2]]
[1] "11" "11" "12"

[[3]]
[1] "111" "112" "121"

> 
> all.equal(aggregation_structure(list(x1, x2, x3)), 
+           aggregation_structure(expand_classification(x3)))
[1] TRUE
> 
> # Unequal weights
> 
> aggregation_structure(list(x1, x2, x3), 1:3)
[[1]]
[1] "1"

[[2]]
[1] "11" "12"

[[3]]
[1] "111" "112" "121"

>           
> # Extract the weights
> 
> weights(aggregation_structure(list(x1, x2, x3)))
[[1]]
1 
3 

[[2]]
11 12 
 2  1 

[[3]]
111 112 121 
  1   1   1 

> 
> # Expanding more complex classifications
> # ... if last 'digit' is either TA or TS
> 
> expand_classification(c("111TA", "112TA", "121TS"), width = c(1, 1, 1, 2))
[[1]]
[1] "1" "1" "1"

[[2]]
[1] "11" "11" "12"

[[3]]
[1] "111" "112" "121"

[[4]]
[1] "111TA" "112TA" "121TS"

> 
> # ... if first 'digit' is either 11 or 12
> 
> expand_classification(c("111", "112", "121"), width = c(2, 1))
[[1]]
[1] "11" "11" "12"

[[2]]
[1] "111" "112" "121"

> 
> # ...if there are delimiters in the classification (like COICOP)
> 
> expand_classification(c("01.1.1", "01.1.2", "01.2.1"), width = c(2, 2, 2))
[[1]]
[1] "01" "01" "01"

[[2]]
[1] "01.1" "01.1" "01.2"

[[3]]
[1] "01.1.1" "01.1.2" "01.2.1"

> 
> 
> 
> cleanEx()
> nameEx("chain")
> ### * chain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: chain
> ### Title: Chain and rebase a price index
> ### Aliases: chain chain.default chain.ind unchain unchain.default
> ###   unchain.ind rebase rebase.default rebase.ind is_chainable_index
> ###   is_chain_index
> 
> ### ** Examples
> 
> prices <- data.frame(rel = 1:8, period = rep(1:2, each = 4), ea = rep(letters[1:2], 4))
> 
> # A simple period-over-period elemental index
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Make period 0 the fixed base period
> 
> chain(epr)
         1        2
a 1.732051 10.24695
b 2.828427 19.59592
> 
> # Chaining and unchaining reverse each other
> 
> all.equal(epr, unchain(chain(epr)))
[1] TRUE
> 
> # Change the base period to period 2 (note the loss of information for period 0)
> 
> epr <- chain(epr)
> rebase(epr, epr[, 2])
          1 2
a 0.1690309 1
b 0.1443376 1
> 
> 
> 
> cleanEx()
> nameEx("contrib")
> ### * contrib
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: contrib
> ### Title: Extract quote contributions
> ### Aliases: contrib contrib.ind
> 
> ### ** Examples
> 
> prices <- data.frame(rel = 1:8, period = rep(1:2, each = 4), ea = rep(letters[1:2], 4))
> 
> epr <- with(prices, elemental_index(rel, period, ea, contrib = TRUE))
> 
> pias <- aggregation_structure(list(c("top", "top", "top"), c("a", "b", "c")), 1:3)
> 
> index <- aggregate(epr, pias, na.rm = TRUE)
> 
> # Quote contributions for the top-level index
> contrib(index)
            1         2
a.1 0.0000000 0.5081686
a.2 0.2440169 0.6442213
b.1 0.3905243 2.0513858
b.2 0.8284271 2.4871732
> 
> # Calculate EA contributions for the chained index
> gpindex::arithmetic_contributions(as.matrix(chain(index))[c("a", "b", "c"), 2], 
+                                   weights(pias, ea_only = TRUE))
       a        b        c 
1.541158 6.198639 7.739798 
> 
> 
> 
> cleanEx()
> nameEx("impute-prices")
> ### * impute-prices
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: impute_prices
> ### Title: Impute prices
> ### Aliases: carry_forward shadow_price
> 
> ### ** Examples
> 
> prices <- data.frame(price = c(1:7, NA), period = rep(1:2, each = 4), 
+                      product = 1:4, ea = rep(letters[1:2], 4))
>                      
> with(prices, carry_forward(price, period, product))
[1] 1 2 3 4 5 6 7 4
> 
> with(prices, shadow_price(price, period, product, ea))
[1]  1  2  3  4  5  6  7 12
> 
> 
> 
> cleanEx()
> nameEx("price-indexes")
> ### * price-indexes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: price_indexes
> ### Title: Price indexes
> ### Aliases: elemental_index elemental_index.default
> ###   elemental_index.numeric aggregate.ind vcov.agg_ind mean.ind merge.ind
> ###   stack.ind unstack.ind [.ind [<-.ind levels.ind time.ind start.ind
> ###   end.ind head.ind tail.ind summary.ind as.matrix.ind as.data.frame.ind
> ###   as_index as_index.default as_index.matrix as_index.data.frame
> ###   is_index is_aggregate_index
> 
> ### ** Examples
> 
> prices <- data.frame(rel = 1:8, period = rep(1:2, each = 4), ea = rep(letters[1:2], 4))
> 
> # A two-level aggregation structure
> 
> pias <- aggregation_structure(list(c("top", "top", "top"), c("a", "b", "c")), 1:3)
> 
> # Calculate Jevons elemental indexes
> 
> (epr <- with(prices, elemental_index(rel, period, ea)))
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Same as using lm() or tapply()
> 
> exp(coef(lm(log(rel) ~ ea:factor(period) - 1, prices)))
eaa:factor(period)1 eab:factor(period)1 eaa:factor(period)2 eab:factor(period)2 
           1.732051            2.828427            5.916080            6.928203 
> 
> with(prices, t(tapply(rel, list(period, ea), gpindex::geometric_mean, na.rm = TRUE)))
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> # Extract the indexes like a matrix
> 
> epr["a", ]
         1       2
a 1.732051 5.91608
> 
> epr[, 2]
         2
a 5.916080
b 6.928203
> 
> epr[1, ] <- 1 # can be useful for doing specific imputations
> 
> # Aggregate (note the imputation for elemental index 'c')
> 
> (index <- aggregate(epr, pias, na.rm = TRUE))
           1        2
top 2.218951 6.037662
a   1.000000 1.000000
b   2.828427 6.928203
c   2.218951 6.037662
> 
> # Aggregation can equivalently be done as matrix multiplication
> 
> as.matrix(pias) %*% as.matrix(chain(index[letters[1:3]]))
           1        2
top 2.218951 13.39728
> 
> # Merge two indexes prior to aggregation
> 
> prices2 <- data.frame(rel = 1:8, period = rep(1:2, each = 4), ea = rep(letters[3:4], 4))
> epr2 <- with(prices2, elemental_index(rel, period, ea))
> aggregate(merge(epr, epr2), pias)
           1        2
top 1.975501 5.984362
a   1.000000 1.000000
b   2.828427 6.928203
c   1.732051 5.916080
> 
> # Stack two indexes prior to aggregation
> 
> prices3 <- data.frame(rel = 1:8, period = rep(3:4, each = 4), ea = rep(letters[1:2], 4))
> epr3 <- with(prices3, elemental_index(rel, period, ea))
> aggregate(stack(epr, epr3), pias)
           1        2        3        4
top       NA       NA       NA       NA
a   1.000000 1.000000 1.732051 5.916080
b   2.828427 6.928203 2.828427 6.928203
c         NA       NA       NA       NA
> 
> # Unstack does the reverse
> 
> all.equal(c(unstack(epr), unstack(epr3)), unstack(stack(epr, epr3)))
[1] TRUE
> 
> # Extract useful features of the index
> 
> head(index, 1)
           1        2
top 2.218951 6.037662
> tail(index, 3)
         1        2
a 1.000000 1.000000
b 2.828427 6.928203
c 2.218951 6.037662
> levels(index)
[1] "top" "a"   "b"   "c"  
> time(index)
[1] "1" "2"
> start(index)
[1] "1"
> end(index)
[1] "2"
> 
> summary(index)
Indexes
       1               2        
 Min.   :1.000   Min.   :1.000  
 1st Qu.:1.914   1st Qu.:4.778  
 Median :2.219   Median :6.038  
 Mean   :2.067   Mean   :5.001  
 3rd Qu.:2.371   3rd Qu.:6.260  
 Max.   :2.828   Max.   :6.928  
> 
> # Turn the index into a data frame/matrix
> 
> as.data.frame(index)
  period level    value
1      1   top 2.218951
2      1     a 1.000000
3      1     b 2.828427
4      1     c 2.218951
5      2   top 6.037662
6      2     a 1.000000
7      2     b 6.928203
8      2     c 6.037662
> as.matrix(index)
           1        2
top 2.218951 6.037662
a   1.000000 1.000000
b   2.828427 6.928203
c   2.218951 6.037662
> 
> all.equal(as_index(as.data.frame(epr)), epr)
[1] TRUE
> all.equal(as_index(as.matrix(epr)), epr)
[1] TRUE
> 
> # Calculate a CSWD index (same as the Jevons in this example) 
> # as an arithmetic index by constructing appropriate weights
> 
> library(gpindex)
> 
> # A general function to calculate weights to turn the geometric
> # mean of the arithmetic and harmonic mean (i.e., Fisher mean)
> # into an arithmetic mean
> 
> fw <- grouped(nested_transmute(0, c(1, -1), 1))
> 
> with(
+     prices, 
+     elemental_index(rel, period, ea, fw(rel, group = interaction(period, ea)), r = 1)
+ )
         1        2
a 1.732051 5.916080
b 2.828427 6.928203
> 
> 
> 
> cleanEx()

detaching â€˜package:gpindexâ€™

> nameEx("price-relative")
> ### * price-relative
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: price_relative
> ### Title: Price relative
> ### Aliases: price_relative
> 
> ### ** Examples
> 
> price_relative(1:6, rep(1:2, each = 3), rep(letters[1:3], 2))
  a   b   c   a   b   c 
1.0 1.0 1.0 4.0 2.5 2.0 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.299 0.027 0.368 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
