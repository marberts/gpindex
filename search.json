[{"path":"https://marberts.github.io/gpindex/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"sec-decompose","dir":"Articles","previous_headings":"","what":"Decomposing generalized-mean indexes","title":"Decomposing price indexes","text":"natural extension decompositions indexes based arithmetic geometric means derive weights transform index based generalized mean order \\(\\rho\\) one based generalized mean order \\(\\varsigma\\). fix notation, let \\(\\mathbf{r} = (r_{1}, r_{2}, \\ldots, r_{n}) \\\\mathbb{R}^{n}_{++}\\) vector price relatives \\(n\\geq2\\) products let \\(\\mathbf{w} = (w_{1}, w_{2}, \\ldots, w_{n}) \\\\Delta^{n - 1}\\) corresponding weights, \\(\\Delta^{n - 1} = \\{\\mathbf{w} \\\\mathbb{R}_{+}^{n} | \\sum_{= 1}^{n} w_{} = 1\\}\\) unit simplex. goal find vector-valued function \\[ \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) = (v_{1}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma), v_{2}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma),\\ldots, v_{n}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma)) \\] mapping \\(\\Delta^{n - 1}\\) \\[ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) \\equiv \\mathfrak{M}_{\\varsigma}(\\mathbf{r}, \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma)), \\] \\(\\mathfrak{M}_{\\rho}\\) generalized mean \\[ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) = \\begin{cases} \\left(\\sum_{= 1}^{n} w_{} r_i^{\\rho}\\right)^{1 / \\rho} & \\text{} \\rho \\neq 0 \\\\ \\prod_{= 1}^{n} r_{}^{w_{}} & \\text{} \\rho = 0. \\end{cases} \\] Setting \\(\\varsigma = 1\\) yields additive decomposition index based generalized mean order \\(\\rho\\), \\[ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) = \\sum_{=1}^{n} r_{} v_i(\\mathbf{r}, \\mathbf{w}; \\rho, 1), \\] setting \\(\\varsigma = 0\\) yields multiplicative decomposition, \\[ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) = \\prod_{=1}^{n} r_{}^{ v_i(\\mathbf{r}, \\mathbf{w}; \\rho, 0)}. \\] Note index admits additive decomposition can used derive percent-change contributions price relative, \\(v_i(\\mathbf{r}, \\mathbf{w}; \\rho, 1) (r_i - 1)\\), sum \\(\\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) - 1\\), although converse true possible decompose index percent-change contributions allow represented arithmetic mean. Note also types decompositions can setting \\(\\varsigma\\) value 0 1; example, setting \\(\\varsigma = -1\\) gives harmonic decomposition, \\[ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) = 1 / \\left(\\sum_{=1}^{n} v_i(\\mathbf{r}, \\mathbf{w}; \\rho, -1) / r_{}\\right), \\] useful Section 2.3. Balk (2008) Reinsdorf, Diewert, Ehemann (2002) show derive \\(\\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma)\\) \\(\\rho = 1\\) \\(\\varsigma = 0\\) (multiplicative decomposition arithmetic index) \\[ v_{}(\\mathbf{r}, \\mathbf{w}; 1, 0) = \\frac{w_{} \\mathfrak{L}(r_{}, \\mathfrak{M}_{1}(\\mathbf{r}, \\mathbf{w}))}{\\sum_{j=1}^{n} w_{j} \\mathfrak{L}(r_{j}, \\mathfrak{M}_{1}(\\mathbf{r}, \\mathbf{w}))} \\] \\(\\rho = 0\\) \\(\\varsigma = 1\\) (additive decomposition geometric index) \\[ v_{}(\\mathbf{r}, \\mathbf{w}; 0, 1) = \\frac{w_{} / \\mathfrak{L}(r_{}, \\mathfrak{M}_{0}(\\mathbf{r}, \\mathbf{w}))}{\\sum_{j=1}^{n} w_{j} / \\mathfrak{L}(r_{j}, \\mathfrak{M}_{0}(\\mathbf{r}, \\mathbf{w}))}, \\] using logarithmic mean \\[ \\mathfrak{L}(, b) = \\begin{cases} \\frac{- b}{\\log(/ b)} & \\neq b\\\\ & = b. \\end{cases} \\] Generalizing results follows replacing logarithmic mean general extended mean (Bullen 2003, 393), defined \\(,b > 0\\) \\[ \\mathfrak{E}_{\\rho\\varsigma}(, b) = \\begin{cases} \\left(\\frac{\\varsigma(^\\rho - b^\\rho)}{\\rho(^\\varsigma - b^\\varsigma)}\\right)^{1 / (\\rho - \\varsigma)} & \\rho \\neq \\varsigma, \\rho \\neq 0, \\varsigma \\neq 0, \\neq b \\\\ \\left(\\frac{^\\rho - b^\\rho}{\\rho\\log(/ b)}\\right)^{1 / \\rho} & \\rho \\neq 0, \\varsigma = 0, \\neq b \\\\ \\left(\\frac{^\\varsigma - b^\\varsigma}{\\varsigma\\log(/ b)}\\right)^{1 / \\varsigma} & \\rho = 0, \\varsigma \\neq 0, \\neq b \\\\ \\frac{1}{\\exp(1 / \\rho)} \\left(\\frac{^{^\\rho}}{b^{b^\\rho}}\\right)^{1 / (^\\rho - b^\\rho)} & \\rho = \\varsigma  \\neq 0, \\neq b \\\\ \\sqrt{ab} & \\rho = \\varsigma = 0, \\neq b \\\\ & = b. \\end{cases} \\] extended mean reduces logarithmic mean either \\(\\rho = 0\\) \\(\\varsigma = 1\\), \\(\\rho = 1\\) \\(\\varsigma = 0\\). using extended mean place logarithmic mean allows decompositions indexes based types means, like harmonic indexes (\\(\\rho = -1\\)) Lloyd-Moulton index (\\(\\rho = 1 - \\sigma\\), \\(\\sigma\\) elasticity substitution). key transforming weights generalized mean order \\(\\rho\\) weights generalized mean order \\(\\varsigma\\) comes noting extended mean always strictly positive satisfies identity \\[ \\sum_{=1}^{n} w_{} \\mathfrak{E}_{\\rho\\varsigma}(r_i, \\mathfrak{M}_{\\rho} (\\mathbf{r}, \\mathbf{w}))^{\\rho - \\varsigma} \\varepsilon_{}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) \\equiv 0, \\tag{1}\\] \\[ \\varepsilon_{}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) = \\begin{cases} r_i^\\varsigma - \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w})^\\varsigma & \\text{} \\varsigma \\neq 0, \\\\ \\log(r_i) - \\log(\\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w})) & \\text{} \\varsigma = 0. \\end{cases} \\] Equation 1 uses extended mean keep weighted deviation mean constant price relative (common factor proportionality) changing order mean \\(\\rho\\) \\(\\varsigma\\), without changing value mean. Rearranging gives \\[ v_{}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) =  w_{} \\mathfrak{E}_{\\rho\\varsigma}(r_i, \\mathfrak{M}_{\\rho} (\\mathbf{r}, \\mathbf{w}))^{\\rho - \\varsigma} \\Bigg/ \\sum_{j=1}^{n} w_{j} \\mathfrak{E}_{\\rho\\varsigma}(r_j, \\mathfrak{M}_{\\rho} (\\mathbf{r}, \\mathbf{w}))^{\\rho - \\varsigma} \\tag{2}\\] suitable function find weights turn index based generalized mean order \\(\\rho\\) one based generalized mean order \\(\\varsigma\\). function given Equation 2 takes existing decompositions know special cases. Setting \\(\\rho = 0\\) \\(\\varsigma = 1\\), \\(\\rho = 1\\) \\(\\varsigma = 0\\), gives special cases Balk (2008) Reinsdorf, Diewert, Ehemann (2002) decomposing indexes based arithmetic geometric means (extended mean reduces logarithmic mean). Similarly, \\(\\mathfrak{E}_{\\rho\\varsigma}(r_i, \\mathfrak{M}_{\\rho} (\\mathbf{r}, \\mathbf{w}))^{\\rho - \\varsigma} \\equiv \\left(\\mathfrak{M}_{\\rho} (\\mathbf{r}, \\mathbf{w}) r_{}\\right)^\\rho\\) \\(\\rho = -1\\) \\(\\varsigma = 1\\), \\(\\rho = 1\\) \\(\\varsigma = -1\\), setting \\(\\rho = -1\\) \\(\\varsigma = 1\\) reduces Equation 2 \\[ v_{}(\\mathbf{r}, \\mathbf{w}; -1, 1) = \\frac{w_{} / r_{}}{\\sum_{=1}^{n}w_{} / r_{}} ; \\] \\(\\mathbf{w}\\) vector current-period expenditure/revenue shares hybrid weights allow Paasche index calculated arithmetic mean price relatives. Setting \\(\\rho = 1\\) \\(\\varsigma = -1\\) reduces Equation 2 \\[ v_{}(\\mathbf{r}, \\mathbf{w}; 1, -1) = \\frac{w_{} r_{}}{\\sum_{=1}^{n}w_{} r_{}}. \\] \\(\\mathbf{w}\\) vector base-period expenditure/revenue shares hybrid weights allow Laspeyres index calculated harmonic mean price relatives. expected, weights unchanged \\(\\rho = \\varsigma\\) element \\(\\mathbf{r}\\) takes value. extended mean two properties make useful decomposing price indexes. First, order extended mean transitivity property multiplication: \\(\\mathfrak{E}_{\\rho\\varsigma}(, b)^{\\rho - \\varsigma} = \\mathfrak{E}_{\\rho\\tau}(, b)^{\\rho - \\tau}\\mathfrak{E}_{\\tau\\varsigma}(, b)^{\\tau - \\varsigma}\\). means function Equation 2 transitivity, transmuting weights turn generalized mean order \\(\\rho\\) generalized mean order \\(\\tau\\), transmuting weights turn generalized mean order \\(\\tau\\) generalized mean order \\(\\varsigma\\), finding weights make generalized mean order \\(\\rho\\) one \\(\\varsigma\\). , \\[ \\mathbf{v}(\\mathbf{r}, \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, \\tau); \\tau, \\varsigma) \\equiv \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma). \\] seen later, decompositions property. Second, extended mean strictly increasing function arguments (Bullen 2003, 395). means function Equation 2 monotonicity property transmuted weights increase (decrease) large (small) price relatives \\(\\rho > \\varsigma\\). , assuming \\(\\mathbf{r}\\) ordered smallest largest (contain value), \\(\\rho > \\varsigma\\) pair integer \\(k,l\\), \\(k\\leq l\\), \\(v_{}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) > w_{}\\) \\(\\geq l\\) \\(v_{}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) < w_{}\\) \\(\\leq k\\), equalities reversed \\(\\rho < \\varsigma\\). , decompositions satisfy property. decomposition given Equation 2 unique \\(n = 2\\) \\(r_{1} \\neq r_{2}\\), function always returns \\(\\mathbf{w}\\) \\(r_{1} = r_{2}\\). Equation 2 necessarily unique \\(n\\geq3\\), infinitely many ways decompose index based generalized mean.2 Nonetheless, limited case uniqueness useful Section 2.1. Consider following numerical example decomposing quadratic-mean index (Lippe 2007, 61) (.e., producer price index elasticity substitution -1) made using price quantity data Balk (2008, tables 3.1 3.2). transmute_weights() function factory parameterizes decomposition Equation 2 make function decomposes generalized-mean index. quadratic mean larger arithmetic mean, weight smaller price relatives transferred largest price relative. also readily seen turning arithmetic decomposition geometric one directly constructing multiplicative decomposition.","code":"library(gpindex)  p2 <- price6[[2]] p1 <- price6[[1]] q2 <- quantity6[[2]] q1 <- quantity6[[1]]  rel <- p2 / p1  s1 <- scale_weights(p1 * q1) s2 <- scale_weights(p2 * q2)  quadratic_mean <- generalized_mean(2) quadratic_decomposition <- transmute_weights(2, 1)  v <- quadratic_decomposition(rel, s1)  all.equal(   quadratic_mean(rel, s1),   arithmetic_mean(rel, v) ) #> [1] TRUE (v - s1)[order(rel)] #> [1] -0.024395704 -0.010503706 -0.007454243 -0.008131901 -0.003049463 #> [6]  0.053535017 all.equal(   transmute_weights(1, 0)(rel, v),   transmute_weights(2, 0)(rel, s1) ) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"transitivity-monotonicity-and-uniqueness","dir":"Articles","previous_headings":"","what":"Transitivity, monotonicity, and uniqueness","title":"Decomposing price indexes","text":"extended mean two properties make useful decomposing price indexes. First, order extended mean transitivity property multiplication: \\(\\mathfrak{E}_{\\rho\\varsigma}(, b)^{\\rho - \\varsigma} = \\mathfrak{E}_{\\rho\\tau}(, b)^{\\rho - \\tau}\\mathfrak{E}_{\\tau\\varsigma}(, b)^{\\tau - \\varsigma}\\). means function Equation 2 transitivity, transmuting weights turn generalized mean order \\(\\rho\\) generalized mean order \\(\\tau\\), transmuting weights turn generalized mean order \\(\\tau\\) generalized mean order \\(\\varsigma\\), finding weights make generalized mean order \\(\\rho\\) one \\(\\varsigma\\). , \\[ \\mathbf{v}(\\mathbf{r}, \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, \\tau); \\tau, \\varsigma) \\equiv \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma). \\] seen later, decompositions property. Second, extended mean strictly increasing function arguments (Bullen 2003, 395). means function Equation 2 monotonicity property transmuted weights increase (decrease) large (small) price relatives \\(\\rho > \\varsigma\\). , assuming \\(\\mathbf{r}\\) ordered smallest largest (contain value), \\(\\rho > \\varsigma\\) pair integer \\(k,l\\), \\(k\\leq l\\), \\(v_{}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) > w_{}\\) \\(\\geq l\\) \\(v_{}(\\mathbf{r}, \\mathbf{w}; \\rho, \\varsigma) < w_{}\\) \\(\\leq k\\), equalities reversed \\(\\rho < \\varsigma\\). , decompositions satisfy property. decomposition given Equation 2 unique \\(n = 2\\) \\(r_{1} \\neq r_{2}\\), function always returns \\(\\mathbf{w}\\) \\(r_{1} = r_{2}\\). Equation 2 necessarily unique \\(n\\geq3\\), infinitely many ways decompose index based generalized mean.2 Nonetheless, limited case uniqueness useful Section 2.1.","code":""},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"numerical-example","dir":"Articles","previous_headings":"","what":"Numerical example","title":"Decomposing price indexes","text":"Consider following numerical example decomposing quadratic-mean index (Lippe 2007, 61) (.e., producer price index elasticity substitution -1) made using price quantity data Balk (2008, tables 3.1 3.2). transmute_weights() function factory parameterizes decomposition Equation 2 make function decomposes generalized-mean index. quadratic mean larger arithmetic mean, weight smaller price relatives transferred largest price relative. also readily seen turning arithmetic decomposition geometric one directly constructing multiplicative decomposition.","code":"library(gpindex)  p2 <- price6[[2]] p1 <- price6[[1]] q2 <- quantity6[[2]] q1 <- quantity6[[1]]  rel <- p2 / p1  s1 <- scale_weights(p1 * q1) s2 <- scale_weights(p2 * q2)  quadratic_mean <- generalized_mean(2) quadratic_decomposition <- transmute_weights(2, 1)  v <- quadratic_decomposition(rel, s1)  all.equal(   quadratic_mean(rel, s1),   arithmetic_mean(rel, v) ) #> [1] TRUE (v - s1)[order(rel)] #> [1] -0.024395704 -0.010503706 -0.007454243 -0.008131901 -0.003049463 #> [6]  0.053535017 all.equal(   transmute_weights(1, 0)(rel, v),   transmute_weights(2, 0)(rel, s1) ) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"extensions","dir":"Articles","previous_headings":"","what":"Extensions","title":"Decomposing price indexes","text":"additive multiplicative decompositions Fisher index Reinsdorf, Diewert, Ehemann (2002, sec. 6) can generalized way decompositions arithmetic geometric indexes noting Fisher index simply nested generalized mean indexes based generalized mean. pair generalized means \\(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2})=\\left(\\mathfrak{M}_{\\rho_1}(\\mathbf{r}, \\mathbf{w}_1), \\mathfrak{M}_{\\rho_2}(\\mathbf{r}, \\mathbf{w}_2)\\right)\\) mapping \\(R_2^{++}\\) weights \\(\\mathbf{\\omega}=(\\omega_1, \\omega_2) \\\\Delta^1\\), index based nested generalized means written \\[ \\mathfrak{M}_{\\rho}\\left(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}\\right). \\tag{3}\\] general family superlative quadratic mean indexes order \\(\\tau\\) comes setting \\(\\rho = 0\\), \\(\\rho_1 = \\tau / 2\\), \\(\\rho_2 = -\\tau / 2\\) \\(\\omega_1 = \\omega_2 = 1 / 2\\), \\(\\mathbf{w}_1\\) base-period expenditure/revenue shares, \\(\\mathbf{w}_2\\) current-period expenditure/revenue shares. particular, setting \\(\\tau = 2\\) gives Fisher index setting \\(\\tau = 1\\) gives implicit Walsh index. Equation 3 covers types indexes well; example, setting element \\(\\mathbf{w}_1\\) \\(\\mathbf{w}_2\\) \\(1 / n\\) \\(\\tau = 2\\) gives Carruthers-Sellwood-Ward-Dalén index serves estimator Fisher index, whereas \\(\\tau = 1\\) gives Balk-Walsh index. Setting \\(\\rho = -1\\) gives harmonic analogue Fisher index, superlative quadratic mean indexes order \\(\\tau\\). Finally, setting \\(\\rho = \\rho_{1} = \\rho_{2}\\) \\(\\mathbf{w}_{1} = \\mathbf{w}_{2}\\) gives index based generalized mean order \\(\\rho\\), decomposition index based generalized mean special case decomposition Equation 3. index form Equation 3 can decomposed index based generalized mean order \\(\\rho\\) using weights Equation 2, can written generalized mean \\[ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\omega_1 \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\rho) + \\omega_2\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\rho)). \\] transformation Equation 2 applies , just replacing \\(\\mathbf{w}\\) complicated weights \\(\\omega_1 \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\rho) + \\omega_2\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2, \\rho_2, \\rho)\\), can written \\[ \\mathbf{v}(\\mathbf{r}, \\omega_1 \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\rho) + \\omega_2\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\rho); \\rho, \\varsigma). \\tag{4}\\] idea transmute weights inner means order outer mean (\\(\\rho\\)) can added together, transmute weights represent outer generalized mean mean order \\(\\varsigma\\). Note means decomposition satisfies transitivity property Equation 2 respect \\(\\rho\\) \\(\\varsigma\\). Continuing previous example, nested_transmute() factory parameterizes decomposition Equation 4 can used decompose Fisher index. alternative approach decompose Equation 3 generalize (additive) van IJzeren decomposition Fisher index, can written \\[ v_{1}(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}; \\rho, \\varsigma) \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\varsigma) + v_{2}(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}; \\rho, \\varsigma) \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\varsigma). \\tag{5}\\] Note Fisher index, \\(\\varsigma=1\\) \\(\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\varsigma)\\) vector base-period expenditure/revenue shares, \\(\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\varsigma)\\) vector hybrid Paasche weights, \\(\\mathbf{v}(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}; \\rho, \\varsigma)\\) unique weights decompose geometric mean Laspeyres Paasche indexes, equals van IJzeren decomposition. idea transmute weights inner outer generalized means means order \\(\\varsigma\\), take product weights. Equation 4 Equation 5 generally give different decompositions, latter transitive, reduce Equation 2 \\(\\rho = \\rho_{1} = \\rho_{2}\\) \\(\\mathbf{w}_{1} = \\mathbf{w}_{2}\\). nested_transmute2() function implements method. Overall difference two approaches tends small. decomposition Equation 5 can extended get decomposition index constructed using usual two-step procedure make price index. price relatives partitioned \\(k\\) groups, index made \\(k\\) sub-indexes \\(\\mathfrak{N}_{\\rho_{1}\\ldots\\rho_{k}}(\\mathbf{r}, \\mathbf{w}_{1}, \\ldots, \\mathbf{w}_{k}) = \\left(\\mathfrak{M}_{\\rho_1}(\\mathbf{r}_{1}, \\mathbf{w}_{1}), \\ldots, \\mathfrak{M}_{\\rho_k}(\\mathbf{r}_{k}, \\mathbf{w}_{k})\\right)\\) weights \\(\\mathbf{\\omega}=(\\omega_{1},\\ldots,\\omega_{k})\\) generalized mean order \\(\\rho\\), \\[ v_{}(\\mathfrak{N}_{\\rho_{1}\\ldots\\rho_{k}}(\\mathbf{r}, \\mathbf{w}_{1}, \\ldots, \\mathbf{w}_{k}), \\mathbf{\\omega}; \\rho, \\varsigma) \\mathbf{v}(\\mathbf{r}_{}, \\mathbf{w}_i; \\rho_{}, \\varsigma) \\] decomposes components \\(\\)-th sub-index contribute towards total index. Concatenating vectors weights along vector price relatives represents nested mean partitioning price relatives generalized mean order \\(\\varsigma\\). decomposition Equation 2 can used construct decomposition price index deflates change aggregate value time get quantity index. Letting \\(V\\) change total value two periods, implicit quantity index price index based generalized mean order \\(\\rho\\) \\[ \\frac{V}{\\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w})}. \\] Using Equation 2 find weights represent \\(\\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w})\\) harmonic mean means \\[ V/ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) \\equiv \\mathfrak{M}_{\\varsigma}(V / \\mathbf{r}, \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, -\\varsigma)), \\tag{6}\\] \\(V / \\mathbf{r} = \\left(V / r_{1}, \\ldots, V / r_{n}\\right)\\). Setting \\(\\varsigma=1\\) gives additive decomposition price relative acts deflate change total value time, setting \\(\\varsigma=0\\) gives multiplicative decomposition. holds true deflating index based nested means, using either Equation 4 Equation 5. von der Lippe (2015) discusses using contra-harmonic mean (antiharmonic calls ), special case Lehmer mean (Bullen 2003, 245) (order 2), make price indexes. Lehmer mean order \\(\\rho\\) simply arithmetic mean weights \\[ \\left(w_{1}r_{1}^{\\rho - 1}, \\ldots, w_{n}r_{n}^{\\rho - 1}\\right) / \\sum_{= 1}^{n} w_{} r_{}^{\\rho - 1}, \\] indexes based means can decomposed Equation 2 using weights instead \\(\\mathbf{w}\\).","code":"v1 <- nested_transmute(0, c(1, -1), 1)(rel, s1, s2)  all.equal(fisher_mean(rel, s1, s2), arithmetic_mean(rel, v1)) #> [1] TRUE  all.equal(   v1,   quadratic_decomposition(rel, nested_transmute(0, c(1, -1), 2)(rel, s1, s2)) ) #> [1] TRUE v2 <- nested_transmute2(0, c(1, -1), 1)(rel, s1, s2)  all.equal(fisher_mean(rel, s1, s2), arithmetic_mean(rel, v2)) #> [1] TRUE  all.equal(   v2,   quadratic_decomposition(rel, nested_transmute2(0, c(1, -1), 2)(rel, s1, s2)) ) #> [1] \"Mean relative difference: 7.760085e-05\" summary(v1 - v2) #>       Min.    1st Qu.     Median       Mean    3rd Qu.       Max.  #> -7.726e-06 -3.059e-06  1.977e-07  0.000e+00  2.617e-06  8.052e-06 group <- rep(c(\"a\", \"b\"), each = 3)  s1_by_group <- split(s1, group) rel_by_group <- split(rel, group)  index_a <- quadratic_mean(rel_by_group$a, s1_by_group$a) index_b <- geometric_mean(rel_by_group$b)  quadratic_mean(c(index_a, index_b), sapply(s1_by_group, sum)) #> [1] 1.375553  decomp_a <- quadratic_decomposition(rel_by_group$a, s1_by_group$a) decomp_b <- transmute_weights(0, 1)(rel_by_group$b)  v <- Map(   `*`,   quadratic_decomposition(c(index_a, index_b), sapply(s1_by_group, sum)),   list(decomp_a, decomp_b) ) |>   unlist()  arithmetic_mean(rel, v) #> [1] 1.375553 V <- sum(p2 * q2) / sum(p1 * q1)  v <- nested_transmute2(0, c(1, -1), -1)(rel, s1, s2)  all.equal(   arithmetic_mean(V / rel, v),   fisher_mean(q2 / q1, s1, s2) ) #> [1] TRUE  V / rel * v #> [1] 0.08971270 0.09467911 0.19432463 0.11454476 0.45833768 0.05478917 # Arithmetic hybrid index all.equal(   arithmetic_mean(p2 / p1, p2 * q1),   contraharmonic_mean(p2 / p1, p1 * q1) ) #> [1] TRUE  # Palgrave index all.equal(   arithmetic_mean(p2 / p1, p2 * q2),   contraharmonic_mean(p2 / p1, p1 * q2) ) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"sec-superlative","dir":"Articles","previous_headings":"","what":"Decomposing superlative indexes","title":"Decomposing price indexes","text":"additive multiplicative decompositions Fisher index Reinsdorf, Diewert, Ehemann (2002, sec. 6) can generalized way decompositions arithmetic geometric indexes noting Fisher index simply nested generalized mean indexes based generalized mean. pair generalized means \\(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2})=\\left(\\mathfrak{M}_{\\rho_1}(\\mathbf{r}, \\mathbf{w}_1), \\mathfrak{M}_{\\rho_2}(\\mathbf{r}, \\mathbf{w}_2)\\right)\\) mapping \\(R_2^{++}\\) weights \\(\\mathbf{\\omega}=(\\omega_1, \\omega_2) \\\\Delta^1\\), index based nested generalized means written \\[ \\mathfrak{M}_{\\rho}\\left(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}\\right). \\tag{3}\\] general family superlative quadratic mean indexes order \\(\\tau\\) comes setting \\(\\rho = 0\\), \\(\\rho_1 = \\tau / 2\\), \\(\\rho_2 = -\\tau / 2\\) \\(\\omega_1 = \\omega_2 = 1 / 2\\), \\(\\mathbf{w}_1\\) base-period expenditure/revenue shares, \\(\\mathbf{w}_2\\) current-period expenditure/revenue shares. particular, setting \\(\\tau = 2\\) gives Fisher index setting \\(\\tau = 1\\) gives implicit Walsh index. Equation 3 covers types indexes well; example, setting element \\(\\mathbf{w}_1\\) \\(\\mathbf{w}_2\\) \\(1 / n\\) \\(\\tau = 2\\) gives Carruthers-Sellwood-Ward-Dalén index serves estimator Fisher index, whereas \\(\\tau = 1\\) gives Balk-Walsh index. Setting \\(\\rho = -1\\) gives harmonic analogue Fisher index, superlative quadratic mean indexes order \\(\\tau\\). Finally, setting \\(\\rho = \\rho_{1} = \\rho_{2}\\) \\(\\mathbf{w}_{1} = \\mathbf{w}_{2}\\) gives index based generalized mean order \\(\\rho\\), decomposition index based generalized mean special case decomposition Equation 3. index form Equation 3 can decomposed index based generalized mean order \\(\\rho\\) using weights Equation 2, can written generalized mean \\[ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\omega_1 \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\rho) + \\omega_2\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\rho)). \\] transformation Equation 2 applies , just replacing \\(\\mathbf{w}\\) complicated weights \\(\\omega_1 \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\rho) + \\omega_2\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2, \\rho_2, \\rho)\\), can written \\[ \\mathbf{v}(\\mathbf{r}, \\omega_1 \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\rho) + \\omega_2\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\rho); \\rho, \\varsigma). \\tag{4}\\] idea transmute weights inner means order outer mean (\\(\\rho\\)) can added together, transmute weights represent outer generalized mean mean order \\(\\varsigma\\). Note means decomposition satisfies transitivity property Equation 2 respect \\(\\rho\\) \\(\\varsigma\\). Continuing previous example, nested_transmute() factory parameterizes decomposition Equation 4 can used decompose Fisher index. alternative approach decompose Equation 3 generalize (additive) van IJzeren decomposition Fisher index, can written \\[ v_{1}(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}; \\rho, \\varsigma) \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\varsigma) + v_{2}(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}; \\rho, \\varsigma) \\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\varsigma). \\tag{5}\\] Note Fisher index, \\(\\varsigma=1\\) \\(\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_1; \\rho_1, \\varsigma)\\) vector base-period expenditure/revenue shares, \\(\\mathbf{v}(\\mathbf{r}, \\mathbf{w}_2; \\rho_2, \\varsigma)\\) vector hybrid Paasche weights, \\(\\mathbf{v}(\\mathfrak{N}_{\\rho_{1}\\rho_{2}}(\\mathbf{r}, \\mathbf{w}_{1}, \\mathbf{w}_{2}), \\mathbf{\\omega}; \\rho, \\varsigma)\\) unique weights decompose geometric mean Laspeyres Paasche indexes, equals van IJzeren decomposition. idea transmute weights inner outer generalized means means order \\(\\varsigma\\), take product weights. Equation 4 Equation 5 generally give different decompositions, latter transitive, reduce Equation 2 \\(\\rho = \\rho_{1} = \\rho_{2}\\) \\(\\mathbf{w}_{1} = \\mathbf{w}_{2}\\). nested_transmute2() function implements method. Overall difference two approaches tends small.","code":"v1 <- nested_transmute(0, c(1, -1), 1)(rel, s1, s2)  all.equal(fisher_mean(rel, s1, s2), arithmetic_mean(rel, v1)) #> [1] TRUE  all.equal(   v1,   quadratic_decomposition(rel, nested_transmute(0, c(1, -1), 2)(rel, s1, s2)) ) #> [1] TRUE v2 <- nested_transmute2(0, c(1, -1), 1)(rel, s1, s2)  all.equal(fisher_mean(rel, s1, s2), arithmetic_mean(rel, v2)) #> [1] TRUE  all.equal(   v2,   quadratic_decomposition(rel, nested_transmute2(0, c(1, -1), 2)(rel, s1, s2)) ) #> [1] \"Mean relative difference: 7.760085e-05\" summary(v1 - v2) #>       Min.    1st Qu.     Median       Mean    3rd Qu.       Max.  #> -7.726e-06 -3.059e-06  1.977e-07  0.000e+00  2.617e-06  8.052e-06"},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"decomposing-aggregated-indexes","dir":"Articles","previous_headings":"","what":"Decomposing aggregated indexes","title":"Decomposing price indexes","text":"decomposition Equation 5 can extended get decomposition index constructed using usual two-step procedure make price index. price relatives partitioned \\(k\\) groups, index made \\(k\\) sub-indexes \\(\\mathfrak{N}_{\\rho_{1}\\ldots\\rho_{k}}(\\mathbf{r}, \\mathbf{w}_{1}, \\ldots, \\mathbf{w}_{k}) = \\left(\\mathfrak{M}_{\\rho_1}(\\mathbf{r}_{1}, \\mathbf{w}_{1}), \\ldots, \\mathfrak{M}_{\\rho_k}(\\mathbf{r}_{k}, \\mathbf{w}_{k})\\right)\\) weights \\(\\mathbf{\\omega}=(\\omega_{1},\\ldots,\\omega_{k})\\) generalized mean order \\(\\rho\\), \\[ v_{}(\\mathfrak{N}_{\\rho_{1}\\ldots\\rho_{k}}(\\mathbf{r}, \\mathbf{w}_{1}, \\ldots, \\mathbf{w}_{k}), \\mathbf{\\omega}; \\rho, \\varsigma) \\mathbf{v}(\\mathbf{r}_{}, \\mathbf{w}_i; \\rho_{}, \\varsigma) \\] decomposes components \\(\\)-th sub-index contribute towards total index. Concatenating vectors weights along vector price relatives represents nested mean partitioning price relatives generalized mean order \\(\\varsigma\\).","code":"group <- rep(c(\"a\", \"b\"), each = 3)  s1_by_group <- split(s1, group) rel_by_group <- split(rel, group)  index_a <- quadratic_mean(rel_by_group$a, s1_by_group$a) index_b <- geometric_mean(rel_by_group$b)  quadratic_mean(c(index_a, index_b), sapply(s1_by_group, sum)) #> [1] 1.375553  decomp_a <- quadratic_decomposition(rel_by_group$a, s1_by_group$a) decomp_b <- transmute_weights(0, 1)(rel_by_group$b)  v <- Map(   `*`,   quadratic_decomposition(c(index_a, index_b), sapply(s1_by_group, sum)),   list(decomp_a, decomp_b) ) |>   unlist()  arithmetic_mean(rel, v) #> [1] 1.375553"},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"sec-harmonic","dir":"Articles","previous_headings":"","what":"Decomposing deflators","title":"Decomposing price indexes","text":"decomposition Equation 2 can used construct decomposition price index deflates change aggregate value time get quantity index. Letting \\(V\\) change total value two periods, implicit quantity index price index based generalized mean order \\(\\rho\\) \\[ \\frac{V}{\\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w})}. \\] Using Equation 2 find weights represent \\(\\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w})\\) harmonic mean means \\[ V/ \\mathfrak{M}_{\\rho}(\\mathbf{r}, \\mathbf{w}) \\equiv \\mathfrak{M}_{\\varsigma}(V / \\mathbf{r}, \\mathbf{v}(\\mathbf{r}, \\mathbf{w}; \\rho, -\\varsigma)), \\tag{6}\\] \\(V / \\mathbf{r} = \\left(V / r_{1}, \\ldots, V / r_{n}\\right)\\). Setting \\(\\varsigma=1\\) gives additive decomposition price relative acts deflate change total value time, setting \\(\\varsigma=0\\) gives multiplicative decomposition. holds true deflating index based nested means, using either Equation 4 Equation 5.","code":"V <- sum(p2 * q2) / sum(p1 * q1)  v <- nested_transmute2(0, c(1, -1), -1)(rel, s1, s2)  all.equal(   arithmetic_mean(V / rel, v),   fisher_mean(q2 / q1, s1, s2) ) #> [1] TRUE  V / rel * v #> [1] 0.08971270 0.09467911 0.19432463 0.11454476 0.45833768 0.05478917"},{"path":"https://marberts.github.io/gpindex/articles/decomposing-indexes.html","id":"decomposing-contra-harmonic-indexes","dir":"Articles","previous_headings":"","what":"Decomposing contra-harmonic indexes","title":"Decomposing price indexes","text":"von der Lippe (2015) discusses using contra-harmonic mean (antiharmonic calls ), special case Lehmer mean (Bullen 2003, 245) (order 2), make price indexes. Lehmer mean order \\(\\rho\\) simply arithmetic mean weights \\[ \\left(w_{1}r_{1}^{\\rho - 1}, \\ldots, w_{n}r_{n}^{\\rho - 1}\\right) / \\sum_{= 1}^{n} w_{} r_{}^{\\rho - 1}, \\] indexes based means can decomposed Equation 2 using weights instead \\(\\mathbf{w}\\).","code":"# Arithmetic hybrid index all.equal(   arithmetic_mean(p2 / p1, p2 * q1),   contraharmonic_mean(p2 / p1, p1 * q1) ) #> [1] TRUE  # Palgrave index all.equal(   arithmetic_mean(p2 / p1, p2 * q2),   contraharmonic_mean(p2 / p1, p1 * q2) ) #> [1] TRUE"},{"path":[]},{"path":"https://marberts.github.io/gpindex/articles/gpindex.html","id":"making-generalized-mean-indexes","dir":"Articles","previous_headings":"","what":"Making generalized-mean indexes","title":"Generalized Price and Quantity Indexes","text":"generalized-mean price index weighted generalized mean price relatives. Given set price relatives weights, generalized-mean price index easily calculated generalized_mean() function. distinguishes different generalized-mean price indexes weights order generalized mean. example, standard Laspeyres index uses base-period value-share weights generalized mean order 1 (arithmetic mean). Changing order generalized mean \\(1 - \\sigma\\), \\(\\sigma\\) elasticity substitution, gives Lloyd-Moulton index, whereas changing weights current-period value-shares gives Palgrave index. essence atomistic approach chapter 2 Selvanathan Rao (1994). Generalized-mean indexes can also nested together get indexes like Fisher, Drobisch, AG mean index. nested_mean() function simple wrapper generalized_mean() cases. top basic mathematical tools functions making standard price indexes prices quantities known. Weights large variety indexes can calculated index_weights(), can plugged relevant generalized mean calculate common price indexes, many uncommon ones. price_index functions provide simple wrapper, quantity_index() function turning analogous quantity index.","code":"library(gpindex)  # Start with some data on prices and quantities for 6 products # over 5 periods price6 #>   t1  t2  t3  t4  t5 #> 1  1 1.2 1.0 0.8 1.0 #> 2  1 3.0 1.0 0.5 1.0 #> 3  1 1.3 1.5 1.6 1.6 #> 4  1 0.7 0.5 0.3 0.1 #> 5  1 1.4 1.7 1.9 2.0 #> 6  1 0.8 0.6 0.4 0.2 quantity6 #>    t1  t2  t3  t4   t5 #> 1 1.0 0.8 1.0 1.2  0.9 #> 2 1.0 0.9 1.1 1.2  1.2 #> 3 2.0 1.9 1.8 1.9  2.0 #> 4 1.0 1.3 3.0 6.0 12.0 #> 5 4.5 4.7 5.0 5.6  6.5 #> 6 0.5 0.6 0.8 1.3  2.5  # We'll only need prices and quantities for a few periods p1 <- price6[[1]] p2 <- price6[[2]] p2 <- price6[[3]] q1 <- quantity6[[1]] q2 <- quantity6[[2]]  s1 <- p1 * q1 s2 <- p1 * q2  # Laspeyres index arithmetic_mean(p1 / p1, s1) #> [1] 1 # Lloyd-Moulton index (elasticity of substitution -1) quadratic_mean <- generalized_mean(2) quadratic_mean(p1 / p1, s1) #> [1] 1  # Palgrave index arithmetic_mean(p1 / p1, s2) #> [1] 1 # Fisher index fisher_mean(p1 / p1, s1, s2) #> [1] 1  # Drobisch index drobisch_mean <- nested_mean(1, c(1, 1)) drobisch_mean(p1 / p1, s1, s2) #> [1] 1  # Geometric AG mean index (elasticity of substitution 0.25) ag_mean <- nested_mean(0, c(0, 1), c(0.25, 0.75)) ag_mean(p1 / p1, s1, s1) #> [1] 1 # Laspeyres index, again arithmetic_mean(p1 / p1, index_weights(\"Laspeyres\")(p1, q1)) #> [1] 1  laspeyres_index(p1, p1, q1) #> [1] 1"},{"path":"https://marberts.github.io/gpindex/articles/gpindex.html","id":"decomposing-indexes","dir":"Articles","previous_headings":"","what":"Decomposing indexes","title":"Generalized Price and Quantity Indexes","text":"Two important functions decomposing generalized means given transmute_weights() factor_weights(). functions augment weights generalized mean, can used calculate percent-change contributions (, e.g., contributions()) price-update weights generalized-mean indexes. Percent-change contributions can similarly calculated indexes nest generalized means.","code":"quadratic_decomposition <- transmute_weights(2, 1)  arithmetic_mean(p1 / p1, quadratic_decomposition(p1 / p1, s1)) #> [1] 1 quadratic_mean(p1 / p1, s1) #> [1] 1  quadratic_contributions <- contributions(2) quadratic_contributions(p1 / p1, s1) #> [1] 0 0 0 0 0 0  quadratic_update <- factor_weights(2)  quadratic_mean(p2 / p1, s1) #> [1] 1.411914 quadratic_mean(p2 / p1, quadratic_update(p1 / p1, s1)) *   quadratic_mean(p1 / p1, s1) #> [1] 1.411914 ag_decomposition <- nested_transmute(0, c(0, 1), 1, c(0.25, 0.75))  ag_mean(p1 / p1, s1, s1) #> [1] 1 arithmetic_mean(p1/ p1, ag_decomposition(p1 / p1, s1, s1)) #> [1] 1  ag_contributions <- nested_contributions(0, c(0, 1), c(0.25, 0.75)) ag_contributions(p1 / p1, s1, s1) #> [1] 0 0 0 0 0 0"},{"path":"https://marberts.github.io/gpindex/articles/gpindex.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Generalized Price and Quantity Indexes","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Selvanathan, E. . Rao, D. S. P. (1994). Index Numbers: Stochastic Approach. MacMillan.","code":""},{"path":"https://marberts.github.io/gpindex/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder.","code":""},{"path":"https://marberts.github.io/gpindex/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2025). gpindex: Generalized Price Quantity Indexes. doi:10.5281/zenodo.10097742, R package version 0.6.3, https://cran.r-project.org/package=gpindex.","code":"@Manual{,   title = {{gpindex}: Generalized Price and Quantity Indexes},   author = {Steve Martin},   year = {2025},   doi = {10.5281/zenodo.10097742},   url = {https://cran.r-project.org/package=gpindex},   note = {R package version 0.6.3}, }"},{"path":"https://marberts.github.io/gpindex/index.html","id":"generalized-price-and-quantity-indexes-","dir":"","previous_headings":"","what":"Generalized Price and Quantity Indexes","title":"Generalized Price and Quantity Indexes","text":"Tools build work bilateral generalized-mean price indexes (extension quantity indexes), indexes composed generalized-mean indexes (e.g., superlative quadratic-mean indexes, GEKS). Covers core mathematical machinery making bilateral price indexes, computing price relatives, detecting outliers, decomposing indexes, wrappers common (many uncommon) index-number formulas. Implements extends many methods Balk (2008), von der Lippe (2007), CPI manual (2020).","code":""},{"path":"https://marberts.github.io/gpindex/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generalized Price and Quantity Indexes","text":"Get stable release CRAN. development version can installed R-Universe directly GitHub.","code":"install.packages(\"gpindex\") install.packages(\"gpindex\", repos = c(\"https://marberts.r-universe.dev\", \"https://cloud.r-project.org\")) pak::pak(\"marberts/gpindex\")"},{"path":"https://marberts.github.io/gpindex/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Generalized Price and Quantity Indexes","text":"","code":"library(gpindex)  # Start with some data on prices and quantities for 6 products # over 5 periods. price6 #>   t1  t2  t3  t4  t5 #> 1  1 1.2 1.0 0.8 1.0 #> 2  1 3.0 1.0 0.5 1.0 #> 3  1 1.3 1.5 1.6 1.6 #> 4  1 0.7 0.5 0.3 0.1 #> 5  1 1.4 1.7 1.9 2.0 #> 6  1 0.8 0.6 0.4 0.2 quantity6 #>    t1  t2  t3  t4   t5 #> 1 1.0 0.8 1.0 1.2  0.9 #> 2 1.0 0.9 1.1 1.2  1.2 #> 3 2.0 1.9 1.8 1.9  2.0 #> 4 1.0 1.3 3.0 6.0 12.0 #> 5 4.5 4.7 5.0 5.6  6.5 #> 6 0.5 0.6 0.8 1.3  2.5  # We'll only need prices and quantities for a few periods. p1 <- price6[[1]] p2 <- price6[[2]] p3 <- price6[[3]] q1 <- price6[[1]] q2 <- price6[[2]]  # There are functions to calculate all common price indexes, # like the Laspeyres and Paasche index. laspeyres_index(p2, p1, q1) #> [1] 1.4 paasche_index(p2, p1, q2) #> [1] 1.811905  # The underlying mean functions are also available, as usually # only price relatives and weights are known. s1 <- p1 * q1 s2 <- p2 * q2  arithmetic_mean(p2 / p1, s1) #> [1] 1.4 harmonic_mean(p2 / p1, s2) #> [1] 1.811905  # The mean representation of a Laspeyres index makes it easy to # chain by price-updating the weights. laspeyres_index(p3, p1, q1) #> [1] 1.05  arithmetic_mean(p2 / p1, s1) *   arithmetic_mean(p3 / p2, update_weights(p2 / p1, s1)) #> [1] 1.05  # The mean representation of a Paasche index makes it easy to # calculate percent-change contributions. harmonic_contributions(p2 / p1, s2) #> [1]  0.02857143  0.71428571  0.04642857 -0.02500000  0.06666667 -0.01904762  # The ideas are the same for more exotic indexes, # like the Lloyd-Moulton index.  # Let's start by making some functions for the Lloyd-Moulton index # when the elasticity of substitution is -1 (an output index). lloyd_moulton <- lm_index(-1) quadratic_mean <- generalized_mean(2) quadratic_update <- factor_weights(2) quadratic_contributions <- contributions(2)  # This index can be calculated as a mean of price relatives. lloyd_moulton(p2, p1, q1) #> [1] 1.592692 quadratic_mean(p2 / p1, s1) #> [1] 1.592692  # Chained over time lloyd_moulton(p3, p1, q1) #> [1] 1.136515 quadratic_mean(p2 / p1, s1) *   quadratic_mean(p3 / p2, quadratic_update(p2 / p1, s1)) #> [1] 1.136515  # And decomposed to get the contributions of each relative. quadratic_contributions(p2 / p1, s1) #> [1]  0.03110568  0.51154526  0.04832926 -0.03830484  0.06666667 -0.02665039"},{"path":"https://marberts.github.io/gpindex/index.html","id":"prior-work","dir":"","previous_headings":"","what":"Prior work","title":"Generalized Price and Quantity Indexes","text":"number R packages CRAN implement standard index-number formulas (e.g., IndexNumber, productivity, IndexNumR, micEconIndex, PriceIndices). support large number index-number formulas --box package, focus tools easily make work type generalized-mean price index. Consequently, compared existing packages, package suitable building custom price/quantity indexes, calculating indexes sample data, decomposing indexes, learning researching different types index-number formulas.","code":""},{"path":"https://marberts.github.io/gpindex/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Generalized Price and Quantity Indexes","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Offset a vector prices or quantities — back_period","title":"Offset a vector prices or quantities — back_period","text":"product, compute either position previous period (back period), position first period (base period). Useful price information stored table.","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Offset a vector prices or quantities — back_period","text":"","code":"back_period(period, product = gl(1, length(period)), match_first = TRUE)  base_period(period, product = gl(1, length(period)), match_first = TRUE)"},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Offset a vector prices or quantities — back_period","text":"period factor, something can coerced one, gives time period transaction. ordering time periods follows levels period agree cut(). product factor, something can coerced one, gives product identifier transaction. default assume transactions product. match_first products first period match (default)?","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Offset a vector prices or quantities — back_period","text":"functions return numeric vector indices back/base periods. back_period(), periods first, resulting vector gives location corresponding product previous period. base_period(), resulting vector gives location corresponding product first period. locations unchanged first time period match_first = TRUE, NA otherwise.","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Offset a vector prices or quantities — back_period","text":"definition, must one transaction product time period determine back/base period. multiple transactions correspond period-product pair, back/base period point time always first position product previous period.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Offset a vector prices or quantities — back_period","text":"","code":"df <- data.frame(   price = 1:6,   product = factor(c(\"a\", \"b\")),   period = factor(c(1, 1, 2, 2, 3, 3)) )  with(df, back_period(period, product)) #> [1] 1 2 1 2 3 4  # Make period-over-period price relatives.  with(df, price / price[back_period(period, product)]) #> [1] 1.000000 1.000000 3.000000 2.000000 1.666667 1.500000  # Make fixed-base price relatives.  with(df, price / price[base_period(period, product)]) #> [1] 1 1 3 2 5 3  # Change the base period with relevel().  with(df, price / price[base_period(relevel(period, \"2\"), product)]) #> [1] 0.3333333 0.5000000 1.0000000 1.0000000 1.6666667 1.5000000  # Warning is given if the same product has multiple prices # at any point in time.  with(df, back_period(period)) #> Warning: there are duplicated period-product pairs #> [1] 1 1 1 1 3 3"},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Balanced operator — balanced","title":"Balanced operator — balanced","text":"Makes function balance removal NAs across multiple input vectors.","code":""},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balanced operator — balanced","text":"","code":"balanced(f, ...)"},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balanced operator — balanced","text":"f function. ... Deprecated. Additional arguments f balanced.","code":""},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balanced operator — balanced","text":"function like f new argument na.rm. na.rm = TRUE complete.cases() used remove missing values across inputs prior calling f.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balanced operator — balanced","text":"","code":"p2 <- price6[[3]] p1 <- price6[[2]] q2 <- quantity6[[3]] q1 <- quantity6[[2]]  # Balance missing values for a Fisher index.  fisher <- balanced(fisher_index) fisher(p2, p1, q2, replace(q1, 3, NA), na.rm = TRUE) #> [1] 0.9015449 fisher_index(p2[-3], p1[-3], q2[-3], q1[-3]) #> [1] 0.9015449"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Percent-change contributions — contributions","title":"Percent-change contributions — contributions","text":"Calculate additive percent-change contributions generalized-mean price indexes, indexes nest two levels generalized means consisting outer generalized mean two inner generalized means (e.g., Fisher index).","code":""},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Percent-change contributions — contributions","text":"","code":"contributions(r)  arithmetic_contributions(x, w = NULL)  geometric_contributions(x, w = NULL)  harmonic_contributions(x, w = NULL)  nested_contributions(r1, r2, t = c(1, 1))  nested_contributions2(r1, r2, t = c(1, 1))  fisher_contributions(x, w1 = NULL, w2 = NULL)  fisher_contributions2(x, w1 = NULL, w2 = NULL)"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Percent-change contributions — contributions","text":"r finite number giving order generalized mean. x strictly positive numeric vector. w, w1, w2 strictly positive numeric vector weights, length x. default equally weight element x. r1 finite number giving order outer generalized mean. r2 pair finite numbers giving order inner generalized means. t pair strictly positive weights inner generalized means. default equal weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Percent-change contributions — contributions","text":"contributions() returns function: nested_contributions() nested_contributions2() return function: arithmetic_contributions(), geometric_contributions(), harmonic_contributions(), fisher_contributions(), fisher_contributions2() return numeric vector, length x.","code":"function(x, w = NULL){...} function(x, w1 = NULL, w2 = NULL){...}"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Percent-change contributions — contributions","text":"function contributions() simple wrapper transmute_weights(r, 1)() calculate (additive) percent-change contributions price index based generalized mean order r. returns function compute vector v(x, w) arithmetic_contributions(), geometric_contributions() harmonic_contributions() functions cover important cases (.e., r = 1, r = 0, r = -1). nested_contributions() nested_contributions2() functions analog contributions() index based nested generalized mean two levels, like Fisher index. wrappers around nested_transmute() nested_transmute2(), respectively. fisher_contributions() fisher_contributions2() functions correspond nested_contributions(0, c(1, -1))() nested_contributions2(0, c(1, -1))(), appropriate calculating percent-change contributions Fisher index.","code":"generalized_mean(r)(x, w) - 1 == sum(v(x, w))"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Percent-change contributions — contributions","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Hallerbach, W. G. (2005). alternative decomposition Fisher index. Economics Letters, 86(2):147–152 Reinsdorf, M. B., Diewert, W. E., Ehemann, C. (2002). Additive decompositions Fisher, Törnqvist geometric mean indexes. Journal Economic Social Measurement, 28(1-2):51–61.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Percent-change contributions — contributions","text":"","code":"p2 <- price6[[2]] p1 <- price6[[1]] q2 <- quantity6[[2]] q1 <- quantity6[[1]]  # Percent-change contributions for the Jevons index.  geometric_mean(p2 / p1) - 1 #> [1] 0.2419201  geometric_contributions(p2 / p1) #> [1]  0.03330510  0.20397490  0.04799594 -0.06452574  0.06163523 -0.04046534  all.equal(   geometric_mean(p2 / p1) - 1,   sum(geometric_contributions(p2 / p1)) ) #> [1] TRUE  # Percent-change contributions for the Fisher index in section 6 of # Reinsdorf et al. (2002).  (con <- fisher_contributions(p2 / p1, p1 * q1, p2 * q2)) #> [1]  0.01782904  0.18814917  0.05792820 -0.03414299  0.18217457 -0.01088796  all.equal(sum(con), fisher_index(p2, p1, q2, q1) - 1) #> [1] TRUE  # Not the only way.  (con2 <- fisher_contributions2(p2 / p1, p1 * q1, p2 * q2)) #> [1]  0.01782865  0.18815627  0.05792735 -0.03414531  0.18217135 -0.01088828  all.equal(sum(con2), fisher_index(p2, p1, q2, q1) - 1) #> [1] TRUE  # The same as the van IJzeren decomposition in section 4.2.2 of # Balk (2008).  Qf <- quantity_index(fisher_index)(q2, q1, p2, p1) Ql <- quantity_index(laspeyres_index)(q2, q1, p1) wl <- scale_weights(p1 * q1) wp <- scale_weights(p1 * q2)  (Qf / (Qf + Ql) * wl + Ql / (Qf + Ql) * wp) * (p2 / p1 - 1) #> [1]  0.01782865  0.18815627  0.05792735 -0.03414531  0.18217135 -0.01088828  # Similar to the method in section 2 of Reinsdorf et al. (2002), # although those contributions aren't based on weights that sum to 1.  Pf <- fisher_index(p2, p1, q2, q1) Pl <- laspeyres_index(p2, p1, q1)  (1 / (1 + Pf) * wl + Pl / (1 + Pf) * wp) * (p2 / p1 - 1) #> [1]  0.01760668  0.18766299  0.05803833 -0.03510719  0.18397180 -0.01112258  # Also similar to the decomposition by Hallerbach (2005), noting that # the Euler weights are close to unity.  Pp <- paasche_index(p2, p1, q2)  (0.5 * sqrt(Pp / Pl) * wl + 0.5 * sqrt(Pl / Pp) * wp) * (p2 / p1 - 1) #> [1]  0.01781577  0.18809422  0.05791874 -0.03417605  0.18220228 -0.01089519"},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Extended mean — extended_mean","title":"Extended mean — extended_mean","text":"Calculate generalized logarithmic mean / extended mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extended mean — extended_mean","text":"","code":"extended_mean(r, s)  generalized_logmean(r)  logmean(a, b, tol = .Machine$double.eps^0.5)"},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extended mean — extended_mean","text":"r, s finite number giving order generalized logarithmic mean / extended mean. , b strictly positive numeric vector. tol tolerance used determine == b.","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extended mean — extended_mean","text":"generalized_logmean() extended_mean() return function: logmean() returns numeric vector, length max(length(), length(b)), giving component-wise logarithmic mean b.","code":"function(a, b, tol = .Machine$double.eps^0.5){...}"},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extended mean — extended_mean","text":"function extended_mean() returns function compute component-wise extended mean b orders r s. See Bullen (2003, p. 393) definition. also called difference mean, Stolarsky mean, extended mean-value mean. function generalized_logmean() returns function compute component-wise generalized logarithmic mean b order r. See Bullen (2003, p. 385) definition. generalized logarithmic mean special case extended mean, corresponding extended_mean(r, 1)(), commonly used price indexes. function logmean() returns ordinary component-wise logarithmic mean b, corresponds generalized_logmean(1)(). b strictly positive. enforced, results may make sense generalized logarithmic mean / extended mean defined. usual recycling rules apply b length. definition, generalized logarithmic mean / extended mean b == b. tol argument used test equality checking abs(- b) <= tol. default value .equal(). cases useful multiply tol scale factor, max(abs(), abs(b)). often matter making price indexes, however, b usually around 1.","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extended mean — extended_mean","text":"generalized_logmean() can defined extended real line, r = -Inf / Inf returns pmin()/pmax(), agree definition , e.g., Bullen (2003). implemented, r must finite.","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extended mean — extended_mean","text":"Bullen, P. S. (2003). Handbook Means Inequalities. Springer Science+Business Media.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extended mean — extended_mean","text":"","code":"x <- 8:5 y <- 1:4  # The arithmetic and geometric means are special cases of the # generalized logarithmic mean.  all.equal(generalized_logmean(2)(x, y), (x + y) / 2) #> [1] TRUE all.equal(generalized_logmean(-1)(x, y), sqrt(x * y)) #> [1] TRUE  # The harmonic mean cannot be expressed as a logarithmic mean, but can # be expressed as an extended mean.  all.equal(extended_mean(-2, -1)(x, y), 2 / (1 / x + 1 / y)) #> [1] TRUE  # The quadratic mean is also a type of extended mean.  all.equal(extended_mean(2, 4)(x, y), sqrt(x^2 / 2 + y^2 / 2)) #> [1] TRUE  # As are heronian and centroidal means.  all.equal(   extended_mean(0.5, 1.5)(x, y),   (x + sqrt(x * y) + y) / 3 ) #> [1] TRUE all.equal(   extended_mean(2, 3)(x, y),   2 / 3 * (x^2 + x * y + y^2) / (x + y) ) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Factor weights — factor_weights","title":"Factor weights — factor_weights","text":"Factor weights turn generalized mean product product generalized means. Useful price-updating weights generalized-mean index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Factor weights — factor_weights","text":"","code":"factor_weights(r)  update_weights(x, w = NULL)"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Factor weights — factor_weights","text":"r finite number giving order generalized mean. x strictly positive numeric vector. w strictly positive numeric vector weights, length x. default equally weight element x.","code":""},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Factor weights — factor_weights","text":"factor_weights() return function: update_weights() returns numeric vector length x.","code":"function(x, w = NULL){...}"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Factor weights — factor_weights","text":"function factor_weights(r) returns function compute weights u(x, w) generalizes result section C.5 Chapter 9 PPI Manual chaining Young index, gives way chain generalized-mean price indexes time. Factoring weights r = 1 sometimes gets called price-updating weights; update_weights() simply calls factor_weights(1)(). Factoring weights return value length x, missing values x weights return NA. Unless values NA, however, result still satisfy identity na.rm = TRUE.","code":"generalized_mean(r)(x * y, w) ==   generalized_mean(r)(x, w) * generalized_mean(r)(y, u(x, w))"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Factor weights — factor_weights","text":"ILO, IMF, OECD, UNECE, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Factor weights — factor_weights","text":"","code":"x <- 1:3 y <- 4:6 w <- 3:1 # Factor the harmonic mean by chaining the calculation.  harmonic_mean(x * y, w) #> [1] 5.966851 harmonic_mean(x, w) * harmonic_mean(y, factor_weights(-1)(x, w)) #> [1] 5.966851  # The common case of an arithmetic mean.  arithmetic_mean(x * y, w) #> [1] 8.333333 arithmetic_mean(x, w) * arithmetic_mean(y, update_weights(x, w)) #> [1] 8.333333  # In cases where x and y have the same order, Chebyshev's # inequality implies that the chained calculation is too small.  arithmetic_mean(x * y, w) >   arithmetic_mean(x, w) * arithmetic_mean(y, w) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":null,"dir":"Reference","previous_headings":"","what":"GEKS index — geks","title":"GEKS index — geks","text":"Calculate generalized inter-temporal GEKS price index rolling window.","code":""},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GEKS index — geks","text":"","code":"geks(f, r = 0)  tornqvist_geks(   p,   q,   period,   product,   window = nlevels(period),   n = window - 1L,   na.rm = FALSE,   match_method = c(\"all\", \"back-price\") )  fisher_geks(   p,   q,   period,   product,   window = nlevels(period),   n = window - 1L,   na.rm = FALSE,   match_method = c(\"all\", \"back-price\") )  walsh_geks(   p,   q,   period,   product,   window = nlevels(period),   n = window - 1L,   na.rm = FALSE,   match_method = c(\"all\", \"back-price\") )"},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GEKS index — geks","text":"f price index function uses information base current-period prices quantities, satisfies time-reversal test. Usually Törnqvist, Fisher, Walsh index. r finite number giving order generalized mean used average price indexes rolling window. default uses geometric mean. p numeric vector prices, length q. q numeric vector quantities, length p. period factor, something can coerced one, gives corresponding time period element p q. ordering time periods follows levels period agree cut(). product factor, something can coerced one, gives corresponding product identifier element p q. window positive integer giving length rolling window. default window encompasses periods period. Non-integers truncated towards zero. n positive integer giving length index series window, starting end window. example, 13 periods window, setting n = 1 gives index period 13. default gives index period window. Non-integers truncated towards zero. na.rm Passed f control missing values removed. match_method Either '' match products (default) 'back-price' match back prices. later can faster lots product imbalanced, used balanced index-number formula f.","code":""},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GEKS index — geks","text":"geks() returns function: calculates period--period GEKS index desired index-number formula, returning list window named-numeric vector index values. tornqvist_geks(), fisher_geks(), walsh_geks() return list named numeric vector giving value respective period--period GEKS index window.","code":"function(p,          q,          period,          product,          window = nlevels(period),          n = window - 1,          na.rm = FALSE,          match_method = c(\"all\", \"back-price\")){...}"},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GEKS index — geks","text":"Like back_period(), multiple prices correspond period-product pair, back price point time always first price product previous period. Unlike bilateral index, however, duplicated period-product pairs can subtle implications multilateral index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"GEKS index — geks","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. Ivancic, L., Diewert, W. E., Fox, K. J. (2011). Scanner data, time aggregation construction price indexes. Journal Econometrics, 161(1): 24–35.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GEKS index — geks","text":"","code":"price <- 1:10 quantity <- 10:1 period <- rep(1:5, 2) product <- rep(letters[1:2], each = 5)  cumprod(tornqvist_geks(price, quantity, period, product)[[1]]) #>        2        3        4        5  #> 1.413257 1.835676 2.284565 2.789856   # Calculate the index over a rolling window.  (tg <- tornqvist_geks(price, quantity, period, product, window = 3)) #> [[1]] #>        2        3  #> 1.391443 1.294442  #>  #> [[2]] #>        3        4  #> 1.292486 1.238393  #>  #> [[3]] #>        4        5  #> 1.238417 1.205921  #>   # Use a movement splice to combine the indexes in each window.  splice_index(tg, 2) #>        2        3        4        5  #> 1.391443 1.801142 2.230521 2.689833   # ... or use a mean splice.  splice_index(tg) #>        2        3        4        5  #> 1.391443 1.801142 2.228836 2.687826   # Use all non-missing data.  quantity[2] <- NA fisher_geks(price, quantity, period, product, na.rm = TRUE) #> [[1]] #>        2        3        4        5  #> 1.438137 1.234230 1.234212 1.216746  #>   # Remove records with any missing data.  fg <- geks(balanced(fisher_index)) fg(price, quantity, period, product, na.rm = TRUE) #> [[1]] #>        2        3        4        5  #> 1.501481 1.148250 1.219688 1.199513  #>   # Make a Jevons GEKS index.  jevons_geks <- geks(\\(p1, p0, ..., na.rm) jevons_index(p1, p0, na.rm)) jevons_geks(price, quantity, period, product) #> [[1]] #>        2        3        4        5  #> 1.527525 1.309307 1.224745 1.178511  #>"},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized mean — generalized_mean","title":"Generalized mean — generalized_mean","text":"Calculate weighted generalized mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized mean — generalized_mean","text":"","code":"generalized_mean(r)  arithmetic_mean(x, w = NULL, na.rm = FALSE)  geometric_mean(x, w = NULL, na.rm = FALSE)  harmonic_mean(x, w = NULL, na.rm = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized mean — generalized_mean","text":"r finite number giving order generalized mean. x strictly positive numeric vector. w strictly positive numeric vector weights, length x. default equally weight element x. na.rm missing values x w removed? default missing values x w return missing value.","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized mean — generalized_mean","text":"generalized_mean() returns function: arithmetic_mean(), geometric_mean(), harmonic_mean() return numeric value generalized means order 1, 0, -1.","code":"function(x, w = NULL, na.rm = FALSE){...}"},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized mean — generalized_mean","text":"function generalized_mean() returns function compute generalized mean x weights w exponent r (.e., \\(\\prod_{= 1}^{n} x_{}^{w_{}}\\) \\(r = 0\\) \\(\\left(\\sum_{= 1}^{n} w_{} x_{}^{r}\\right)^{1 / r}\\) otherwise). also called power mean, Hölder mean, \\(l_p\\) mean; see Bullen (2003, p. 175) details. functions arithmetic_mean(), geometric_mean(), harmonic_mean() compute arithmetic, geometric, harmonic (subcontrary) means, also known Pythagorean means. useful means making price indexes, correspond setting r = 1, r = 0, r = -1 generalized_mean(). x w strictly positive (finite), especially purpose making price index. enforced, results may make sense generalized mean defined. two exceptions . convention Hardy et al. (1952, p. 13) used cases x zeros: generalized mean 0 whenever w strictly positive r < 0. (analogous convention holds whenever least one element x Inf: generalized mean Inf whenever w strictly positive r > 0.) authors let w non-negative sum 1 (e.g., Sydsaeter et al., 2005, p. 47). w zeros, corresponding element x impact mean whenever x strictly positive. Unlike weighted.mean(), however, zeros w strong zeros, infinite values x propagate even corresponding elements w zero. weights scaled sum 1 satisfy definition generalized mean. certain price indexes weights scaled (e.g., Vartia-index); use sum() cases. underlying calculation returned generalized_mean() mostly identical weighted.mean(), one important exception: missing values weights treated differently missing values x. Setting na.rm = TRUE drops missing values x w, just x. ensures certain useful identities satisfied missing values x. cases arithmetic_mean() drop-replacement weighted.mean().","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generalized mean — generalized_mean","text":"generalized_mean() can defined extended real line, r = -Inf / Inf returns min()/max(), agree definition , e.g., Bullen (2003). implemented, r must finite. number existing functions calculating unweighted geometric harmonic means, namely geometric.mean() harmonic.mean() functions psych package, geomean() function FSA package, GMean() HMean() functions DescTools package, geoMean() function EnvStats package. Similarly, ci_generalized_mean() function Compind package calculates unweighted generalized mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized mean — generalized_mean","text":"Bullen, P. S. (2003). Handbook Means Inequalities. Springer Science+Business Media. Fisher, . (1922). Making Index Numbers. Houghton Mifflin Company. Hardy, G., Littlewood, J. E., Polya, G. (1952). Inequalities (2nd edition). Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. Lord, N. (2002). Smaller Spread Always Mean Larger Product? Mathematical Gazette, 86(506): 273-274. Sydsaeter, K., Strom, ., Berck, P. (2005). Economists' Mathematical Manual (4th edition). Springer.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized mean — generalized_mean","text":"","code":"x <- 1:3 w <- c(0.25, 0.25, 0.5)  # The dispersion between the arithmetic, geometric, and harmonic # mean usually increases as the variance of 'x' increases.  x <- c(1, 3, 5) y <- c(2, 3, 4)  var(x) > var(y) #> [1] TRUE  arithmetic_mean(x) - geometric_mean(x) #> [1] 0.5337879 arithmetic_mean(y) - geometric_mean(y) #> [1] 0.1155009  geometric_mean(x) - harmonic_mean(x) #> [1] 0.5096903 geometric_mean(y) - harmonic_mean(y) #> [1] 0.1152684  # But the dispersion between these means is only bounded by the # variance (Bullen, 2003, p. 156).  arithmetic_mean(x) - geometric_mean(x) >= 2 / 3 * var(x) / (2 * max(x)) #> [1] TRUE arithmetic_mean(x) - geometric_mean(x) <= 2 / 3 * var(x) / (2 * min(x)) #> [1] TRUE  # Example by Lord (2002) where the dispersion decreases as the variance # increases, counter to the claims by Fisher (1922, p. 108) and the # CPI manual (par. 1.14)  x <- (5 + c(sqrt(5), -sqrt(5), -3)) / 4 y <- (16 + c(7 * sqrt(2), -7 * sqrt(2), 0)) / 16  var(x) > var(y) #> [1] TRUE  arithmetic_mean(x) - geometric_mean(x) #> [1] 0.145012 arithmetic_mean(y) - geometric_mean(y) #> [1] 0.1485894  geometric_mean(x) - harmonic_mean(x) #> [1] 0.104988 geometric_mean(y) - harmonic_mean(y) #> [1] 0.1439479  # The \"bias\" in the arithmetic and harmonic indexes is also smaller in # this case, counter to the claim by Fisher (1922, p. 108)  arithmetic_mean(x) * arithmetic_mean(1 / x) - 1 #> [1] 0.3333333 arithmetic_mean(y) * arithmetic_mean(1 / y) - 1 #> [1] 0.4135021  harmonic_mean(x) * harmonic_mean(1 / x) - 1 #> [1] -0.25 harmonic_mean(y) * harmonic_mean(1 / y) - 1 #> [1] -0.2925373"},{"path":"https://marberts.github.io/gpindex/reference/gpindex-package.html","id":null,"dir":"Reference","previous_headings":"","what":"gpindex: Generalized Price and Quantity Indexes — gpindex-package","title":"gpindex: Generalized Price and Quantity Indexes — gpindex-package","text":"Tools build work bilateral generalized-mean price indexes (extension quantity indexes), indexes composed generalized-mean indexes (e.g., superlative quadratic-mean indexes, GEKS). Covers core mathematical machinery making bilateral price indexes, computing price relatives, detecting outliers, decomposing indexes, wrappers common (many uncommon) index-number formulas. Implements extends many methods Balk (2008, doi:10.1017/CBO9780511720758 ), von der Lippe (2007, doi:10.3726/978-3-653-01120-3 ), CPI manual (2020, doi:10.5089/9781484354841.069 ).","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/gpindex-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"gpindex: Generalized Price and Quantity Indexes — gpindex-package","text":"Maintainer: Steve Martin marberts@protonmail.com (ORCID) [copyright holder]","code":""},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":null,"dir":"Reference","previous_headings":"","what":"Grouped operator — grouped","title":"Grouped operator — grouped","text":"Make function applicable grouped data.","code":""},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grouped operator — grouped","text":"","code":"grouped(f, ...)"},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grouped operator — grouped","text":"f function. ... Deprecated. Additional arguments f treated grouped.","code":""},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grouped operator — grouped","text":"function like f new argument group. accepts factor split arguments f groups applying f group combining results. similar ave(), general.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grouped operator — grouped","text":"","code":"# Redistribute weights.  x <- 1:6 w <- c(1:5, NA) f <- factor(rep(letters[1:2], each = 3)) w1 <- c(2, 4) w2 <- 1:6  harmonic_mean(mapply(harmonic_mean, split(x, f), split(w2, f)), w1) #> [1] 3.333333  wr <- grouped(scale_weights)(w2, group = f) * w1[f] harmonic_mean(x, wr) #> [1] 3.333333"},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Index weights — index_weights","title":"Index weights — index_weights","text":"Calculate weights variety different price indexes.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index weights — index_weights","text":"","code":"index_weights(   type = c(\"Carli\", \"Jevons\", \"Coggeshall\", \"Dutot\", \"Laspeyres\", \"HybridLaspeyres\",     \"LloydMoulton\", \"Palgrave\", \"Paasche\", \"HybridPaasche\", \"Drobisch\", \"Unnamed\",     \"Tornqvist\", \"Walsh1\", \"Walsh2\", \"MarshallEdgeworth\", \"GearyKhamis\", \"Vartia1\",     \"MontgomeryVartia\", \"Vartia2\", \"SatoVartia\", \"Theil\", \"Rao\", \"Lowe\", \"Young\",     \"HybridCSWD\") )"},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index weights — index_weights","text":"type name index. See details possible types indexes.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index weights — index_weights","text":"function current base period prices/quantities calculates relevant weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Index weights — index_weights","text":"index_weights() function returns function calculate weights variety price indexes. Weights following types indexes can calculated. Carli / Jevons / Coggeshall Dutot Laspeyres / Lloyd-Moulton Hybrid Laspeyres (use harmonic mean) Paasche / Palgrave Hybrid Paasche (use arithmetic mean) Törnqvist / Unnamed Drobisch Walsh-(arithmetic Walsh index) Walsh-II (geometric Walsh index) Marshall-Edgeworth Geary-Khamis Montgomery-Vartia / Vartia-Sato-Vartia / Vartia-II Theil Rao Lowe Young Hybrid-CSWD weights need sum 1, normalization always appropriate (.e., Vartia-weights).","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Index weights — index_weights","text":"Naming indexes weights generally follows CPI manual (2020), Balk (2008), von der Lippe (2007), Selvanathan Rao (1994). several cases two names correspond weights (e.g., Paasche Palgrave, Sato-Vartia Vartia-II). calculations given examples.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Index weights — index_weights","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang. Selvanathan, E. . Rao, D. S. P. (1994). Index Numbers: Stochastic Approach. MacMillan.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Index weights — index_weights","text":"","code":"p1 <- price6[[2]] p2 <- price6[[3]] q1 <- quantity6[[2]] q2 <- quantity6[[3]] pb <- price6[[1]] qb <- quantity6[[1]]  # Explicit calculation for each of the different weights # Carli/Jevons/Coggeshall  all.equal(index_weights(\"Carli\")(p2), rep(1, length(p1))) #> [1] TRUE  # Dutot  all.equal(index_weights(\"Dutot\")(p1), p1) #> [1] TRUE  # Laspeyres / Lloyd-Moulton  all.equal(index_weights(\"Laspeyres\")(p1, q1), p1 * q1) #> [1] TRUE  # Hybrid Laspeyres  all.equal(index_weights(\"HybridLaspeyres\")(p2, q1), p2 * q1) #> [1] TRUE  # Paasche / Palgrave  all.equal(index_weights(\"Paasche\")(p2, q2), p2 * q2) #> [1] TRUE  # Hybrid Paasche  all.equal(index_weights(\"HybridPaasche\")(p1, q2), p1 * q2) #> [1] TRUE  # Tornqvist / Unnamed  all.equal(   index_weights(\"Tornqvist\")(p2, p1, q2, q1),   0.5 * p1 * q1 / sum(p1 * q1) + 0.5 * p2 * q2 / sum(p2 * q2) ) #> [1] TRUE  # Drobisch  all.equal(   index_weights(\"Drobisch\")(p2, p1, q2, q1),   0.5 * p1 * q1 / sum(p1 * q1) + 0.5 * p1 * q2 / sum(p1 * q2) ) #> [1] TRUE  # Walsh-I  all.equal(   index_weights(\"Walsh1\")(p1, q2, q1),   p1 * sqrt(q1 * q2) ) #> [1] TRUE  # Marshall-Edgeworth  all.equal(   index_weights(\"MarshallEdgeworth\")(p1, q2, q1),   p1 * (q1 + q2) ) #> [1] TRUE  # Geary-Khamis  all.equal(   index_weights(\"GearyKhamis\")(p1, q2, q1),   p1 / (1 / q1 + 1 / q2) ) #> [1] TRUE  # Montgomery-Vartia / Vartia-I  all.equal(   index_weights(\"MontgomeryVartia\")(p2, p1, q2, q1),   logmean(p1 * q1, p2 * q2) / logmean(sum(p1 * q1), sum(p2 * q2)) ) #> [1] TRUE  # Sato-Vartia / Vartia-II  all.equal(   index_weights(\"SatoVartia\")(p2, p1, q2, q1),   logmean(p1 * q1 / sum(p1 * q1), p2 * q2 / sum(p2 * q2)) ) #> [1] TRUE  # Walsh-II  all.equal(   index_weights(\"Walsh2\")(p2, p1, q2, q1),   sqrt(p1 * q1 * p2 * q2) ) #> [1] TRUE  # Theil  all.equal(index_weights(\"Theil\")(p2, p1, q2, q1), {   w0 <- scale_weights(p1 * q1)   w1 <- scale_weights(p2 * q2)   (w0 * w1 * (w0 + w1) / 2)^(1 / 3) }) #> [1] TRUE  # Rao  all.equal(index_weights(\"Rao\")(p2, p1, q2, q1), {   w0 <- scale_weights(p1 * q1)   w1 <- scale_weights(p2 * q2)   w0 * w1 / (w0 + w1) }) #> [1] TRUE  # Lowe  all.equal(index_weights(\"Lowe\")(p1, qb), p1 * qb) #> [1] TRUE  # Young  all.equal(index_weights(\"Young\")(pb, qb), pb * qb) #> [1] TRUE  # Hybrid CSWD (to approximate a CSWD index)  all.equal(index_weights(\"HybridCSWD\")(p2, p1), sqrt(p1 / p2)) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Lehmer mean — lehmer_mean","title":"Lehmer mean — lehmer_mean","text":"Calculate weighted Lehmer mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lehmer mean — lehmer_mean","text":"","code":"lehmer_mean(r)  contraharmonic_mean(x, w = NULL, na.rm = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lehmer mean — lehmer_mean","text":"r finite number giving order Lehmer mean. x strictly positive numeric vector. w strictly positive numeric vector weights, length x. default equally weight element x. na.rm missing values x w removed? default missing values x w return missing value.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lehmer mean — lehmer_mean","text":"lehmer_mean() returns function: contraharmonic_mean() returns numeric value Lehmer mean order 2.","code":"function(x, w = NULL, na.rm = FALSE){...}"},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lehmer mean — lehmer_mean","text":"function lehmer_mean() returns function compute Lehmer mean order r x weights w, calculated arithmetic mean x weights \\(wx^{r-1}\\). also called counter-harmonic mean generalized anti-harmonic mean. See Bullen (2003, p. 245) details. Lehmer mean order 2 sometimes called contraharmonic (anti-harmonic) mean. function contraharmonic_mean() simply calls lehmer_mean(2)(). See von der Lippe (2015) details use means making price indexes.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Lehmer mean — lehmer_mean","text":"lehmer_mean() can defined extended real line, r = -Inf / Inf returns min()/max(), agree definition , e.g., Bullen (2003). implemented, r must finite.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lehmer mean — lehmer_mean","text":"Bullen, P. S. (2003). Handbook Means Inequalities. Springer Science+Business Media. von der Lippe, P. (2015). Generalized Statistical Means New Price Index Formulas, Notes unexplored index formulas, interpretations generalizations. Munich Personal RePEc Archive paper . 64952.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lehmer mean — lehmer_mean","text":"","code":"x <- 2:3 w <- c(0.25, 0.75)  # The Pythagorean means are special cases of the Lehmer mean.  all.equal(lehmer_mean(1)(x, w), arithmetic_mean(x, w)) #> [1] TRUE all.equal(lehmer_mean(0)(x, w), harmonic_mean(x, w)) #> [1] TRUE all.equal(lehmer_mean(0.5)(x), geometric_mean(x)) #> [1] TRUE  # When r < 1, the generalized mean is larger than the corresponding # Lehmer mean.  lehmer_mean(-1)(x, w) < generalized_mean(-1)(x, w) #> [1] TRUE  # The reverse is true when r > 1.  lehmer_mean(3)(x, w) > generalized_mean(3)(x, w) #> [1] TRUE  # This implies the contraharmonic mean is larger than the quadratic # mean, and therefore the Pythagorean means.  contraharmonic_mean(x, w) > arithmetic_mean(x, w) #> [1] TRUE contraharmonic_mean(x, w) > geometric_mean(x, w) #> [1] TRUE contraharmonic_mean(x, w) > harmonic_mean(x, w) #> [1] TRUE  # ... and the logarithmic mean  contraharmonic_mean(2:3) > logmean(2, 3) #> [1] TRUE  # The difference between the arithmetic mean and contraharmonic mean # is proportional to the variance of x.  weighted_var <- function(x, w) {   arithmetic_mean((x - arithmetic_mean(x, w))^2, w) }  arithmetic_mean(x, w) + weighted_var(x, w) / arithmetic_mean(x, w) #> [1] 2.818182 contraharmonic_mean(x, w) #> [1] 2.818182"},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Nested generalized mean — nested_mean","title":"Nested generalized mean — nested_mean","text":"Calculate (outer) generalized mean two (inner) generalized means (.e., crossing generalized means).","code":""},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nested generalized mean — nested_mean","text":"","code":"nested_mean(r1, r2, t = c(1, 1))  fisher_mean(x, w1 = NULL, w2 = NULL, na.rm = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nested generalized mean — nested_mean","text":"r1 finite number giving order outer generalized mean. r2 pair finite numbers giving order inner generalized means. t pair strictly positive weights inner generalized means. default equal weights. x strictly positive numeric vector. w1, w2 strictly positive numeric vector weights, length x. default equally weight element x. na.rm missing values x, w1, w2 removed? default missing values x, w1, w2 return missing value.","code":""},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nested generalized mean — nested_mean","text":"nested_mean() returns function: computes generalized mean order r1 generalized mean order r2[1] x weights w1 generalized mean order r2[2] x weights w2. fisher_mean() returns numeric value geometric mean arithmetic harmonic means (.e., r1 = 0 r2 = c(1, -1)).","code":"function(x, w1 = NULL, w2 = NULL, na.rm = FALSE){...}"},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Nested generalized mean — nested_mean","text":"ambiguity remove missing values w1 w2 na.rm = TRUE. approach remove missing values calculating inner means individually, rather removing missing values prior calculations. means different number data points used calculate inner means. Use balanced() operator balance missing values across w1 w2 prior calculations.","code":""},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nested generalized mean — nested_mean","text":"ILO, IMF, OECD, UNECE, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nested generalized mean — nested_mean","text":"","code":"x <- 1:3 w1 <- 4:6 w2 <- 7:9  # A function to make the superlative quadratic mean price index as # a product of generalized means.  quadratic_mean_index <- function(r) nested_mean(0, c(r / 2, -r / 2))  quadratic_mean_index(2)(x, w1, w2) #> [1] 1.912366  fisher_mean(x, w1, w2) #> [1] 1.912366  # The (arithmetic) Walsh index is the implicit price index when using a # superlative quadratic mean quantity index of order 1.  p2 <- price6[[2]] p1 <- price6[[1]] q2 <- quantity6[[2]] q1 <- quantity6[[1]]  walsh <- quadratic_mean_index(1)  sum(p2 * q2) / sum(p1 * q1) / walsh(q2 / q1, p1 * q1, p2 * q2) #> [1] 1.401718  sum(p2 * sqrt(q2 * q1)) / sum(p1 * sqrt(q2 * q1)) #> [1] 1.401718  # Counter to the PPI manual (par. 1.105), it is not a superlative # quadratic mean price index of order 1.  walsh(p2 / p1, p1 * q1, p2 * q2) #> [1] 1.401534  # That requires using the average value share as weights.  walsh_weights <- sqrt(scale_weights(p1 * q1) * scale_weights(p2 * q2)) walsh(p2 / p1, walsh_weights, walsh_weights) #> [1] 1.401718"},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier detection for price relatives — outliers","title":"Outlier detection for price relatives — outliers","text":"Standard cutoff-based methods detecting outliers price relatives.","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier detection for price relatives — outliers","text":"","code":"quartile_method(x, cu = 2.5, cl = cu, a = 0, type = 7)  resistant_fences(x, cu = 2.5, cl = cu, a = 0, type = 7)  kimber_method(x, cu = 2.5, cl = cu, a = 0, type = 7)  robust_z(x, cu = 2.5, cl = cu)  fixed_cutoff(x, cu = 2.5, cl = 1/cu)  tukey_algorithm(x, cu = 2.5, cl = cu, type = 7)  hb_transform(x)"},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier detection for price relatives — outliers","text":"x numeric vector, usually price relatives. can made , e.g., back_period(). cu, cl number giving upper lower cutoffs element x. number 0 1 giving scale factor median establish minimum dispersion quartiles element x. default set minimum dispersion. type See quantile().","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier detection for price relatives — outliers","text":"logical vector, length x, TRUE corresponding element x identified outlier, FALSE otherwise.","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Outlier detection for price relatives — outliers","text":"functions constructs interval form \\([b_l(x) - c_l \\times l(x), b_u(x) + c_u \\times u(x)]\\) assigns value x TRUE value belong interval, FALSE otherwise. methods differ construct values \\(b_l(x)\\), \\(b_u(x)\\), \\(l(x)\\), \\(u(x)\\). missing values x ignored calculating cutoffs, return NA. fixed cutoff method simplest, just uses interval \\([c_l, c_u]\\). quartile method Tukey algorithm described paragraphs 5.113 5.135 CPI manual (2020), well Rais (2008) Hutton (2008). resistant fences method alternative quartile method, described Rais (2008) Hutton (2008). Kimber method yet another alternative. Quantile-based methods often identify price relatives outliers distribution concentrated around 1; setting > 0 puts floor minimum dispersion quantiles fraction median. See references details. robust Z-score usual method identify relatives (asymmetric) tails distribution, simply replacing mean median, standard deviation median absolute deviation. methods often assume price relatives symmetrically distributed (Gaussian). distribution price relatives often long right tail, natural logarithm can used transform price relative identifying outliers (sometimes assumption price relatives distributed log-normal). Hidiroglou-Berthelot transformation another approach, described CPI manual (par. 5.124). (Sometimes transformed price relatives multiplied \\(\\max(p_1, p_0)^u\\), \\(0 \\le u \\le 1\\), products larger price get flagged outliers (par. 5.128).)","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outlier detection for price relatives — outliers","text":"Hutton, H. (2008). Dynamic outlier detection price index surveys. Proceedings Survey Methods Section: Statistical Society Canada Annual Meeting. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. Rais, S. (2008). Outlier detection Consumer Price Index. Proceedings Survey Methods Section: Statistical Society Canada Annual Meeting.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier detection for price relatives — outliers","text":"","code":"set.seed(1234)  x <- rlnorm(10)  fixed_cutoff(x) #>  [1]  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE robust_z(x) #>  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE quartile_method(x) #>  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE resistant_fences(x) # always identifies fewer outliers than above #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE tukey_algorithm(x) #>  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  log(x) #>  [1] -1.2070657  0.2774292  1.0844412 -2.3456977  0.4291247  0.5060559 #>  [7] -0.5747400 -0.5466319 -0.5644520 -0.8900378 hb_transform(x) #>  [1] -0.918538151  1.300051411  4.154877789 -4.990623335  1.676813038 #>  [6]  1.890871823 -0.019423964  0.008909836 -0.008989935 -0.397291327  # Works the same for grouped data.  f <- c(\"a\", \"b\", \"a\", \"a\", \"b\", \"b\", \"b\", \"a\", \"a\", \"b\") grouped(quartile_method)(x, group = f) #>  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE"},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample price/quantity data — price_data","title":"Sample price/quantity data — price_data","text":"Prices quantities six products five periods.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample price/quantity data — price_data","text":"data frame 6 rows 5 columns, row corresponding product column corresponding time period.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample price/quantity data — price_data","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. ILO, IMF, OECD, UNECE, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample price/quantity data — price_data","text":"Adapted tables 3.1 3.2 Balk (2008), adapted tables 19.1 19.2 PPI manual.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample price/quantity data — price_data","text":"","code":"# Recreate tables 3.4, 3.6, and 3.12 from Balk (2008).  index_formulas <- function(p1, p0, q1, q0) {   c(     harmonic_laspeyres = harmonic_index(\"Laspeyres\")(p1, p0, q0),     geometric_laspeyres = geometric_index(\"Laspeyres\")(p1, p0, q0),     laspeyres = arithmetic_index(\"Laspeyres\")(p1, p0, q0),     paasche = harmonic_index(\"Paasche\")(p1, p0, q1),     geometric_paasche = geometric_index(\"Paasche\")(p1, p0, q1),     palgrave = arithmetic_index(\"Palgrave\")(p1, p0, q1),     fisher = fisher_index(p1, p0, q1, q0),     tornqvist = geometric_index(\"Tornqvist\")(p1, p0, q1, q0),     marshall_edgeworth = arithmetic_index(\"MarshallEdgeworth\")(p1, p0, q1, q0),     walsh1 = arithmetic_index(\"Walsh1\")(p1, p0, q1, q0),     vartia2 = geometric_index(\"Vartia2\")(p1, p0, q1, q0),     vartia1 = geometric_index(\"Vartia1\")(p1, p0, q1, q0),     stuvel = stuvel_index(2, 2)(p1, p0, q1, q0)   ) }  round(t(mapply(index_formulas, price6, price6[1], quantity6, quantity6[1])), 4) #>    harmonic_laspeyres geometric_laspeyres laspeyres paasche geometric_paasche #> t1             1.0000              1.0000     1.000  1.0000            1.0000 #> t2             1.2542              1.3300     1.420  1.3824            1.4846 #> t3             1.1346              1.2523     1.345  1.2031            1.3268 #> t4             0.8732              1.1331     1.355  1.0209            1.3282 #> t5             0.5556              1.0999     1.440  0.7968            1.4153 #>    palgrave fisher tornqvist marshall_edgeworth walsh1 vartia2 vartia1 stuvel #> t1   1.0000 1.0000    1.0000             1.0000 1.0000  1.0000  1.0000 1.0000 #> t2   1.6096 1.4011    1.4052             1.4010 1.4017  1.4018  1.4024 1.4042 #> t3   1.4161 1.2721    1.2890             1.2656 1.2850  1.2897  1.2907 1.2742 #> t4   1.5317 1.1762    1.2268             1.1438 1.2193  1.2335  1.2392 1.1551 #> t5   1.6720 1.0712    1.2477             0.9801 1.1850  1.2540  1.2678 0.9770"},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Price indexes — price_indexes","title":"Price indexes — price_indexes","text":"Calculate variety price indexes using information prices quantities two points time.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Price indexes — price_indexes","text":"","code":"arithmetic_index(type)  geometric_index(type)  harmonic_index(type)  laspeyres_index(p1, p0, q0, na.rm = FALSE)  paasche_index(p1, p0, q1, na.rm = FALSE)  jevons_index(p1, p0, na.rm = FALSE)  lowe_index(p1, p0, qb, na.rm = FALSE)  young_index(p1, p0, pb, qb, na.rm = FALSE)  fisher_index(p1, p0, q1, q0, na.rm = FALSE)  hlp_index(p1, p0, q1, q0, na.rm = FALSE)  lm_index(elasticity)  cswd_index(p1, p0, na.rm = FALSE)  cswdb_index(p1, p0, q1, q0, na.rm = FALSE)  bw_index(p1, p0, na.rm = FALSE)  stuvel_index(a, b)  arithmetic_agmean_index(elasticity)  geometric_agmean_index(elasticity)  lehr_index(p1, p0, q1, q0, na.rm = FALSE)  martini_index(a)"},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Price indexes — price_indexes","text":"type name index. See details possible types indexes. p1 Current-period prices. p0 Base-period prices. q0 Base-period quantities. na.rm missing values removed? default missing values prices quantities return missing value. q1 Current-period quantities. qb Period-b quantities Lowe/Young index. pb Period-b prices Lowe/Young index. elasticity elasticity substitution Lloyd-Moulton AG mean indexes. , b Parameters generalized Stuvel index Martini index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Price indexes — price_indexes","text":"arithmetic_index(), geometric_index(), harmonic_index(), stuvel_index() return function compute relevant price indexes; lm_index(), arithmetic_agmean_index(), geometric_agmean_index() return function calculate relevant index given elasticity substitution. others return numeric value giving change price base period current period.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Price indexes — price_indexes","text":"arithmetic_index(), geometric_index(), harmonic_index() functions return function calculate given type arithmetic, geometric (logarithmic), harmonic index. Together, functions produce functions calculate following indexes. Arithmetic indexes Carli Dutot Laspeyres Palgrave Unnamed index (arithmetic mean Laspeyres Palgrave) Drobisch (Sidgwick, arithmetic mean Laspeyres Paasche) Walsh-(arithmetic Walsh) Marshall-Edgeworth Geary-Khamis Lowe Young Hybrid-CSWD Geometric indexes Jevons Geometric Laspeyres (Jöhr) Geometric Paasche Geometric Young Törnqvist (Törnqvist-Theil) Montgomery-Vartia / Vartia-Sato-Vartia / Vartia-II Walsh-II (geometric Walsh) Theil Rao Harmonic indexes Coggeshall (equally weighted harmonic index) Paasche Harmonic Laspeyres Harmonic Young Along lm_index() function calculate Lloyd-Moulton index, just convenient wrappers generalized_mean() index_weights(). Laspeyres, Paasche, Jevons, Lowe, Young indexes among common price indexes, get functions. laspeyres_index(), lowe_index(), young_index() functions correspond setting appropriate type arithmetic_index(); paasche_index() jevons_index() instead come harmonic_index() geometric_index() functions. addition indexes, also functions calculating variety indexes based nested generalized means. Fisher index geometric mean arithmetic Laspeyres Paasche indexes; Harmonic Laspeyres Paasche (Harmonic Paasche Laspeyres) index harmonic analog Fisher index (8054 Fisher's list). Carruthers-Sellwood-Ward-Dalen Carruthers-Sellwood-Ward-Dalen-Balk indexes sample analogs Fisher index; Balk-Walsh index sample analog Walsh index. AG mean index arithmetic geometric mean geometric arithmetic Laspeyres indexes, weighted elasticity substitution. stuvel_index() function returns function calculate Stuvel index given parameters. Lehr index alternative Geary-Khamis index, implicit price index Fisher's index 4153. Martini index Lowe index quantities weighted geometric average current base period quantities.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Price indexes — price_indexes","text":"different ways deal missing values price index, care taken relying functions remove missing values. Setting na.rm = TRUE removes price relatives missing information, either missing price missing weight, using available non-missing information make weights. Certain properties index-number formula may work expected removing missing values ambiguity remove missing values weights (, e.g., Törnqvist Sato-Vartia index). balanced() operator may helpful, balances removal missing values across prices quantities prior making weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Price indexes — price_indexes","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Fisher, . (1922). Making Index Numbers. Houghton Mifflin Company. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang. Selvanathan, E. . Rao, D. S. P. (1994). Index Numbers: Stochastic Approach. MacMillan.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Price indexes — price_indexes","text":"","code":"p1 <- price6[[2]] p2 <- price6[[3]] q1 <- quantity6[[2]] q2 <- quantity6[[3]]  # Most indexes can be calculated by combining the appropriate weights # with the correct type of mean.  laspeyres_index(p2, p1, q1) #> [1] 0.9609929 arithmetic_mean(p2 / p1, index_weights(\"Laspeyres\")(p1, q1)) #> [1] 0.9609929  geometric_index(\"Laspeyres\")(p2, p1, q1) #> [1] 0.8705581 geometric_mean(p2 / p1, index_weights(\"Laspeyres\")(p1, q1)) #> [1] 0.8705581  # NAs get special treatment.  p_na <- replace(p1, 6, NA)  laspeyres_index(p2, p_na, q1, na.rm = TRUE) # drops the last price relative #> [1] 0.9684288  sum(p2 * q1, na.rm = TRUE) /   sum(p_na * q1, na.rm = TRUE) # drops the last period-0 price #> [1] 0.9948605  # von Bortkiewicz decomposition  paasche_index(p2, p1, q2) / laspeyres_index(p2, p1, q1) - 1 #> [1] -0.04099992  wl <- scale_weights(index_weights(\"Laspeyres\")(p1, q1)) pl <- laspeyres_index(p2, p1, q1) ql <- quantity_index(laspeyres_index)(q2, q1, p1)  sum(wl * (p2 / p1 / pl - 1) * (q2 / q1 / ql - 1)) #> [1] -0.04099992  # Similar decomposition for geometric Laspeyres/Paasche.  wp <- scale_weights(index_weights(\"Paasche\")(p2, q2)) gl <- geometric_index(\"Laspeyres\")(p2, p1, q1) gp <- geometric_index(\"Paasche\")(p2, p1, q2)  log(gp / gl) #> [1] 0.1388242  sum(scale_weights(wl) * (wp / wl - 1) * log(p2 / p1 / gl)) #> [1] 0.1388242"},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantity index operator — quantity_index","title":"Quantity index operator — quantity_index","text":"Remaps price arguments quantity argument (vice versa) turn price index quantity index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantity index operator — quantity_index","text":"","code":"quantity_index(f)"},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantity index operator — quantity_index","text":"f price-index function.","code":""},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantity index operator — quantity_index","text":"function like f, except role prices/quantities reversed.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantity index operator — quantity_index","text":"","code":"p1 <- price6[[3]] p0 <- price6[[2]] q1 <- quantity6[[3]] q0 <- quantity6[[2]]  # Remap argument names to be quantities rather than prices.  quantity_index(laspeyres_index)(q1 = q1, q0 = q0, p0 = p0) #> [1] 1.175887  laspeyres_index(p1 = q1, p0 = q0, q0 = p0) #> [1] 1.175887  # Works with the index_weights() functions, too.  quantity_index(index_weights(\"Laspeyres\"))(q0 = q0, p0 = p0) #> [1] 0.96 2.70 2.47 0.91 6.58 0.48"},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale weights — scale_weights","title":"Scale weights — scale_weights","text":"Scale vector weights sum 1.","code":""},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale weights — scale_weights","text":"","code":"scale_weights(x)"},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale weights — scale_weights","text":"x strictly positive numeric vector.","code":""},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale weights — scale_weights","text":"numeric vector sums 1. NAs x result sums 1 values removed.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale weights — scale_weights","text":"","code":"scale_weights(1:5) #> [1] 0.06666667 0.13333333 0.20000000 0.26666667 0.33333333  scale_weights(c(1:5, NA)) #> [1] 0.06666667 0.13333333 0.20000000 0.26666667 0.33333333         NA"},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Splice an index series — splice_index","title":"Splice an index series — splice_index","text":"Splice collection index series computed rolling window one index series. Splicing multiple points combines results geometric mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splice an index series — splice_index","text":"","code":"splice_index(x, periods = NULL, initial = NULL, published = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splice an index series — splice_index","text":"x list equal-length numeric vectors giving period--period indexes window. periods integer vector giving splice points window. default splices point window. initial numeric vector giving initial period--period index series onto elements x spliced. default uses first element x. published splice done published series? default splices using recalculated index series.","code":""},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splice an index series — splice_index","text":"numeric vector giving spliced (fixed-base) index series.","code":""},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Splice an index series — splice_index","text":"Chessa, . G. (2019). Comparison Index Extension Methods Multilateral Methods. Paper presented 16th Meeting Ottawa Group Price Indices, 8-10 May 2019, Rio de Janeiro, Brazil. Krsinich, F. (2016). FEWS index: Fixed effects window splice. Journal Official Statistics, 32(2), 375-404.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splice an index series — splice_index","text":"","code":"# Make an index series over a rolling window.  x <- list(c(1.1, 0.9, 1.2), c(0.8, 1.3, 1.4), c(1.3, 1.3, 0.8))  # Mean splice.  splice_index(x) #> [1] 1.100000 0.990000 1.188000 1.686819 1.284405  # Movement splice.  splice_index(x, 3) #> [1] 1.10000 0.99000 1.18800 1.66320 1.33056  # Window splice.  splice_index(x, 1) #> [1] 1.10000 0.99000 1.18800 1.60160 1.18976  # Splicing on the published series preserves the within-window # movement of the index series.  splice_index(x, 1, published = TRUE) #> [1] 1.10000 0.99000 1.18800 1.60160 1.33848"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Transmute weights — transmute_weights","title":"Transmute weights — transmute_weights","text":"Transmute weights turn generalized mean order \\(r\\) generalized mean order \\(s\\). Useful calculating additive multiplicative decompositions generalized-mean index, made nested generalized means (e.g., Fisher index).","code":""},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transmute weights — transmute_weights","text":"","code":"transmute_weights(r, s)  nested_transmute(r1, r2, s, t = c(1, 1))  nested_transmute2(r1, r2, s, t = c(1, 1))"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transmute weights — transmute_weights","text":"r, s finite number giving order generalized mean. See details. r1 finite number giving order outer generalized mean. r2 pair finite numbers giving order inner generalized means. t pair strictly positive weights inner generalized means. default equal weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transmute weights — transmute_weights","text":"transmute_weights() returns function: nested_transmute() nested_transmute2() similarly return function:","code":"function(x, w = NULL, tol = .Machine$double.eps^0.5){...} function(x, w1 = NULL, w2 = NULL, tol = .Machine$double.eps^0.5){...}"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transmute weights — transmute_weights","text":"function transmute_weights(r, s) returns function compute vector weights v(x, w) nested_transmute(r1, r2, t, s) nested_transmute2(r1, r2, t, s) nested generalized means, Transmuting weights returns value length x, missing values x weights return NA. Unless values NA, however, result still satisfy identities na.rm = TRUE.","code":"generalized_mean(r)(x, w) == generalized_mean(s)(x, v(x, w)) nested_mean(r1, r2, t)(x, w1, w2) ==   generalized_mean(s)(x, v(x, w1, w2))"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Transmute weights — transmute_weights","text":"See vignette(\"decomposing-indexes\") details.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transmute weights — transmute_weights","text":"","code":"x <- 1:3 w <- 3:1  # Calculate the geometric mean as an arithmetic mean and # harmonic mean by transmuting the weights.  geometric_mean(x) #> [1] 1.817121 arithmetic_mean(x, transmute_weights(0, 1)(x)) #> [1] 1.817121 harmonic_mean(x, transmute_weights(0, -1)(x)) #> [1] 1.817121  # Works for nested means, too.  w1 <- 3:1 w2 <- 1:3  fisher_mean(x, w1, w2) #> [1] 1.825742  arithmetic_mean(x, nested_transmute(0, c(1, -1), 1)(x, w1, w2)) #> [1] 1.825742 arithmetic_mean(x, nested_transmute2(0, c(1, -1), 1)(x, w1, w2)) #> [1] 1.825742"},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-063","dir":"Changelog","previous_headings":"","what":"gpindex 0.6.3","title":"gpindex 0.6.3","text":"Bumped minimum version R >= 4.1. geks() now faster uses less memory makes GEKS index. Time periods entirely missing data longer return index value geks(), fixing #8. Added new vignette better explain decomposing index. Added martini_index() compute family Martini indexes. Added kimber_method() outlier detection. Outlier detection functions now stricter inputs. Functions transmuting weights now get tol argument control tolerance extended mean.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-062","dir":"Changelog","previous_headings":"","what":"gpindex 0.6.2","title":"gpindex 0.6.2","text":"CRAN release: 2024-08-16 splice_index() now keeps names. Fixed bug transmute_weights() weights negative. Price-index functions better argument checking.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-061","dir":"Changelog","previous_headings":"","what":"gpindex 0.6.1","title":"gpindex 0.6.1","text":"CRAN release: 2024-04-12 Updated maintainer email. Added parameter generalize geks() controlling indexes averaged rolling window. Fixed bug transmute_weights() factor_weights() return result different length w. Added new function splice_index() splicing indexes calculated rolling window (previously sketched example). transmute_weights() now faster.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-060","dir":"Changelog","previous_headings":"","what":"gpindex 0.6.0","title":"gpindex 0.6.0","text":"CRAN release: 2023-11-15 Bumped minimum version R least 4.0. use ... grouped() balanced() deprecated, removed future version. behavior can using anonymous function. Added walsh_geks() function. back_period() base_period() gain new argument match_first control whether products first period match return NA. Updated documentation. Added brief vignette.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-050","dir":"Changelog","previous_headings":"","what":"gpindex 0.5.0","title":"gpindex 0.5.0","text":"CRAN release: 2023-08-08 back_price() base_price() removed. Functions transforming weights keep attributes weights (), documented. grouped() longer mangles names.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-043","dir":"Changelog","previous_headings":"","what":"gpindex 0.4.3","title":"gpindex 0.4.3","text":"CRAN release: 2022-05-01 back_price() base_price() deprecated favor general back_period() base_period() functions. removed future version. algorithm making GEKS indexes now much faster rolling window.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-042","dir":"Changelog","previous_headings":"","what":"gpindex 0.4.2","title":"gpindex 0.4.2","text":"CRAN release: 2022-01-26 functions overall structure package fairly stable now . Added nested_transmute() nested_transmute2() transmuting weights nested generalized means. consistent argument names, first two arguments nested_mean() nested_contributions*() now r1 r2. Added geometric Theil Rao indexes.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-039","dir":"Changelog","previous_headings":"","what":"gpindex 0.3.9","title":"gpindex 0.3.9","text":"CRAN release: 2021-11-26 Added back_period() base_period(), general back_price() base_price(). Added lehr_index(). Fixed rare warning sqrt() making NaNs generalized_logmean(-1) inputs close equal, despite NaNs showing result. lm_index() *_agmean_index() functions now function factories.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-036","dir":"Changelog","previous_headings":"","what":"gpindex 0.3.6","title":"gpindex 0.3.6","text":"CRAN release: 2021-10-02 Added balanced() operator make easier remove NAs price index functions. Added geks() function using price-index function (e.g., fisher_index()) makes GEKS index.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-034","dir":"Changelog","previous_headings":"","what":"gpindex 0.3.4","title":"gpindex 0.3.4","text":"CRAN release: 2021-08-04 Added French translations. Made number optimizations make results generalized_mean(), extended_mean(), lehmer_mean(), transmute_weights(), factor_weights() faster common cases. Added grouped() operator make functions work grouped data.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"gpindex-031","dir":"Changelog","previous_headings":"","what":"gpindex 0.3.1","title":"gpindex 0.3.1","text":"CRAN release: 2021-07-07 function names changed less awkward; e.g., mean_generalized() now generalized_mean(), contributions_geometric() now geometric_contributions(). unfortunately backwards compatible, needed done. Added nested_mean() function calculate nested generalized means , e.g., Fisher index. interface nested_contributions() now much simpler, function focused making contributions Fisher indexes. Added nested_contributions2() function implements different algorithm. Added arithmetic_agmean_index() geometric_agmean_index() functions calculate AG mean index. Added functions standard outlier-detection methods price relatives. Dropped scale argument generalized_mean(), really wasn’t needed potential make problems solved.","code":""}]
