[{"path":"https://marberts.github.io/gpindex/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 Steve Martin Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://marberts.github.io/gpindex/articles/gpindex.html","id":"making-generalized-mean-indexes","dir":"Articles","previous_headings":"","what":"Making generalized-mean indexes","title":"Generalized Price and Quantity Indexes","text":"generalized-mean price index weighted generalized mean price relatives. Given set price relatives weights, generalized-mean price index easily calculated generalized_mean() function. distinguishes different generalized-mean price indexes weights order generalized mean. example, standard Laspeyres index uses base-period value-share weights generalized mean order 1 (arithmetic mean). Changing order generalized mean \\(1 - \\sigma\\), \\(\\sigma\\) elasticity substitution, gives Lloyd-Moulton index, whereas changing weights current-period value-shares gives Palgrave index. essence atomistic approach chapter 2 Selvanathan Rao (1994). Generalized-mean indexes can also nested together get indexes like Fisher, Drobisch, AG mean index. nested_mean() function simple wrapper generalized_mean() cases. top basic mathematical tools functions making standard price indexes prices quantities known. Weights large variety indexes can calculated index_weights(), can plugged relevant generalized mean calculate common price indexes, many uncommon ones. price_index functions provide simple wrapper, quantity_index() function turning analogous quantity index.","code":"library(gpindex)  # Start with some data on prices and quantities for 6 products # over 5 periods price6 #>   t1  t2  t3  t4  t5 #> 1  1 1.2 1.0 0.8 1.0 #> 2  1 3.0 1.0 0.5 1.0 #> 3  1 1.3 1.5 1.6 1.6 #> 4  1 0.7 0.5 0.3 0.1 #> 5  1 1.4 1.7 1.9 2.0 #> 6  1 0.8 0.6 0.4 0.2 quantity6 #>    t1  t2  t3  t4   t5 #> 1 1.0 0.8 1.0 1.2  0.9 #> 2 1.0 0.9 1.1 1.2  1.2 #> 3 2.0 1.9 1.8 1.9  2.0 #> 4 1.0 1.3 3.0 6.0 12.0 #> 5 4.5 4.7 5.0 5.6  6.5 #> 6 0.5 0.6 0.8 1.3  2.5  # We'll only need prices and quantities for a few periods p0 <- price6[[1]] p1 <- price6[[2]] p2 <- price6[[3]] q0 <- quantity6[[1]] q1 <- quantity6[[2]]  s0 <- p0 * q0 s1 <- p1 * q1  # Laspeyres index arithmetic_mean(p1 / p0, s0) #> [1] 1.42 # Lloyd-Moulton index (elasticity of substitution -1) quadratic_mean <- generalized_mean(2) quadratic_mean(p1 / p0, s0) #> [1] 1.531339  # Palgrave index arithmetic_mean(p1 / p0, s1) #> [1] 1.609645 # Fisher index fisher_mean(p1 / p0, s0, s1) #> [1] 1.40105  # Drobisch index drobisch_mean <- nested_mean(1, c(1, 1)) drobisch_mean(p1 / p0, s0, s1) #> [1] 1.514823  # Geometric AG mean index (elasticity of substitution 0.25) ag_mean <- nested_mean(0, c(0, 1), c(0.25, 0.75)) ag_mean(p1 / p0, s0, s0) #> [1] 1.396936 # Laspeyres index, again arithmetic_mean(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) #> [1] 1.42  laspeyres_index(p1, p0, q0) #> [1] 1.42"},{"path":"https://marberts.github.io/gpindex/articles/gpindex.html","id":"decomposing-indexes","dir":"Articles","previous_headings":"","what":"Decomposing indexes","title":"Generalized Price and Quantity Indexes","text":"Two important functions decomposing generalized means given transmute_weights() factor_weights(). functions augment weights generalized mean, can used calculate percent-change contributions (, e.g., contributions()) price-update weights generalized-mean indexes. Percent-change contributions can similarly calculated indexes nest generalized means.","code":"quadratic_decomposition <- transmute_weights(2, 1)  arithmetic_mean(p1 / p0, quadratic_decomposition(p1 / p0, s0)) #> [1] 1.531339 quadratic_mean(p1 / p0, s0) #> [1] 1.531339  quadratic_contributions <- contributions(2) quadratic_contributions(p1 / p0, s0) #> [1]  0.018509151  0.307070035  0.057560430 -0.022681289  0.178780215 #> [6] -0.007899259  quadratic_update <- factor_weights(2)  quadratic_mean(p2 / p0, s0) #> [1] 1.411914 quadratic_mean(p2 / p1, quadratic_update(p1 / p0, s0)) *   quadratic_mean(p1 / p0, s0) #> [1] 1.411914 ag_decomposition <- nested_transmute(0, c(0, 1), 1, c(0.25, 0.75))  ag_mean(p1 / p0, s0, s0) #> [1] 1.396936 arithmetic_mean(p1/ p0, ag_decomposition(p1 / p0, s0, s0)) #> [1] 1.396936  ag_contributions <- nested_contributions(0, c(0, 1), c(0.25, 0.75)) ag_contributions(p1 / p0, s0, s0) #> [1]  0.02021474  0.18159654  0.06002349 -0.03261592  0.17838867 -0.01067166"},{"path":"https://marberts.github.io/gpindex/articles/gpindex.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Generalized Price and Quantity Indexes","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Selvanathan, E. . Rao, D. S. P. (1994). Index Numbers: Stochastic Approach. MacMillan.","code":""},{"path":"https://marberts.github.io/gpindex/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Martin. Author, maintainer, copyright holder.","code":""},{"path":"https://marberts.github.io/gpindex/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin S (2025). gpindex: Generalized Price Quantity Indexes. doi:10.5281/zenodo.10097742, R package version 0.6.2.9001, https://cran.r-project.org/package=gpindex.","code":"@Manual{,   title = {{gpindex}: Generalized Price and Quantity Indexes},   author = {Steve Martin},   year = {2025},   doi = {10.5281/zenodo.10097742},   url = {https://cran.r-project.org/package=gpindex},   note = {R package version 0.6.2.9001}, }"},{"path":"https://marberts.github.io/gpindex/index.html","id":"generalized-price-and-quantity-indexes-","dir":"","previous_headings":"","what":"Generalized Price and Quantity Indexes","title":"Generalized Price and Quantity Indexes","text":"Tools build work bilateral generalized-mean price indexes (extension quantity indexes), indexes composed generalized-mean indexes (e.g., superlative quadratic-mean indexes, GEKS). Covers core mathematical machinery making bilateral price indexes, computing price relatives, detecting outliers, decomposing indexes, wrappers common (many uncommon) index-number formulas. Implements extends many methods Balk (2008), von der Lippe (2007), CPI manual (2020).","code":""},{"path":"https://marberts.github.io/gpindex/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Generalized Price and Quantity Indexes","text":"Get stable release CRAN. development version can installed R-Universe directly GitHub.","code":"install.packages(\"gpindex\") install.packages(\"gpindex\", repos = c(\"https://marberts.r-universe.dev\", \"https://cloud.r-project.org\")) pak::pak(\"marberts/gpindex\")"},{"path":"https://marberts.github.io/gpindex/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Generalized Price and Quantity Indexes","text":"","code":"library(gpindex)  # Start with some data on prices and quantities for 6 products # over 5 periods price6 #>   t1  t2  t3  t4  t5 #> 1  1 1.2 1.0 0.8 1.0 #> 2  1 3.0 1.0 0.5 1.0 #> 3  1 1.3 1.5 1.6 1.6 #> 4  1 0.7 0.5 0.3 0.1 #> 5  1 1.4 1.7 1.9 2.0 #> 6  1 0.8 0.6 0.4 0.2 quantity6 #>    t1  t2  t3  t4   t5 #> 1 1.0 0.8 1.0 1.2  0.9 #> 2 1.0 0.9 1.1 1.2  1.2 #> 3 2.0 1.9 1.8 1.9  2.0 #> 4 1.0 1.3 3.0 6.0 12.0 #> 5 4.5 4.7 5.0 5.6  6.5 #> 6 0.5 0.6 0.8 1.3  2.5  # We'll only need prices and quantities for a few periods p0 <- price6[[1]] p1 <- price6[[2]] p2 <- price6[[3]] q0 <- price6[[1]] q1 <- price6[[2]]  # There are functions to calculate all common price indexes, # like the Laspeyres and Paasche index laspeyres_index(p1, p0, q0) #> [1] 1.4 paasche_index(p1, p0, q1) #> [1] 1.811905  # The underlying mean functions are also available, as usually # only price relatives and weights are known s0 <- p0 * q0 s1 <- p1 * q1  arithmetic_mean(p1 / p0, s0) #> [1] 1.4 harmonic_mean(p1 / p0, s1) #> [1] 1.811905  # The mean representation of a Laspeyres index makes it easy to # chain by price-updating the weights laspeyres_index(p2, p0, q0) #> [1] 1.05  arithmetic_mean(p1 / p0, s0) *   arithmetic_mean(p2 / p1, update_weights(p1 / p0, s0)) #> [1] 1.05  # The mean representation of a Paasche index makes it easy to # calculate percent-change contributions harmonic_contributions(p1 / p0, s1) #> [1]  0.02857143  0.71428571  0.04642857 -0.02500000  0.06666667 -0.01904762  # The ideas are the same for more exotic indexes, # like the Lloyd-Moulton index  # Let's start by making some functions for the Lloyd-Moulton index # when the elasticity of substitution is -1 (an output index) lloyd_moulton <- lm_index(-1) quadratic_mean <- generalized_mean(2) quadratic_update <- factor_weights(2) quadratic_contributions <- contributions(2)  # This index can be calculated as a mean of price relatives lloyd_moulton(p1, p0, q0) #> [1] 1.592692 quadratic_mean(p1 / p0, s0) #> [1] 1.592692  # Chained over time lloyd_moulton(p2, p0, q0) #> [1] 1.136515 quadratic_mean(p1 / p0, s0) *   quadratic_mean(p2 / p1, quadratic_update(p1 / p0, s0)) #> [1] 1.136515  # And decomposed to get the contributions of each relative quadratic_contributions(p1 / p0, s0) #> [1]  0.03110568  0.51154526  0.04832926 -0.03830484  0.06666667 -0.02665039"},{"path":"https://marberts.github.io/gpindex/index.html","id":"prior-work","dir":"","previous_headings":"","what":"Prior work","title":"Generalized Price and Quantity Indexes","text":"number R packages CRAN implement standard index-number formulas (e.g., IndexNumber, productivity, IndexNumR, micEconIndex, PriceIndices). support large number index-number formulas --box package, focus tools easily make work type generalized-mean price index. Consequently, compared existing packages, package suitable building custom price/quantity indexes, calculating indexes sample data, decomposing indexes, learning researching different types index-number formulas.","code":""},{"path":"https://marberts.github.io/gpindex/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Generalized Price and Quantity Indexes","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang.","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Offset a vector prices or quantities — back_period","title":"Offset a vector prices or quantities — back_period","text":"product, compute either position previous period (back period), position first period (base period). Useful price information stored table.","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Offset a vector prices or quantities — back_period","text":"","code":"back_period(period, product = gl(1, length(period)), match_first = TRUE)  base_period(period, product = gl(1, length(period)), match_first = TRUE)"},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Offset a vector prices or quantities — back_period","text":"period factor, something can coerced one, gives time period transaction. ordering time periods follows levels period agree cut(). product factor, something can coerced one, gives product identifier transaction. default assume transactions product. match_first products first period match (default)?","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Offset a vector prices or quantities — back_period","text":"functions return numeric vector indices back/base periods. back_period(), periods first, resulting vector gives location corresponding product previous period. base_period(), resulting vector gives location corresponding product first period. locations unchanged first time period match_first = TRUE, NA otherwise.","code":""},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Offset a vector prices or quantities — back_period","text":"definition, must one transaction product time period determine back/base period. multiple transactions correspond period-product pair, back/base period point time always first position product previous period.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/back_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Offset a vector prices or quantities — back_period","text":"","code":"df <- data.frame(   price = 1:6,   product = factor(c(\"a\", \"b\")),   period = factor(c(1, 1, 2, 2, 3, 3)) )  with(df, back_period(period, product)) #> [1] 1 2 1 2 3 4  # Make period-over-period price relatives  with(df, price / price[back_period(period, product)]) #> [1] 1.000000 1.000000 3.000000 2.000000 1.666667 1.500000  # Make fixed-base price relatives  with(df, price / price[base_period(period, product)]) #> [1] 1 1 3 2 5 3  # Change the base period with relevel()  with(df, price / price[base_period(relevel(period, \"2\"), product)]) #> [1] 0.3333333 0.5000000 1.0000000 1.0000000 1.6666667 1.5000000  # Warning is given if the same product has multiple prices # at any point in time  with(df, back_period(period)) #> Warning: there are duplicated period-product pairs #> [1] 1 1 1 1 3 3"},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Balanced operator — balanced","title":"Balanced operator — balanced","text":"Makes function balance removal NAs across multiple input vectors.","code":""},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Balanced operator — balanced","text":"","code":"balanced(f, ...)"},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Balanced operator — balanced","text":"f function. ... Deprecated. Additional arguments f balanced.","code":""},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Balanced operator — balanced","text":"function like f new argument na.rm. na.rm = TRUE complete.cases() used remove missing values across inputs prior calling f.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/balanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Balanced operator — balanced","text":"","code":"p1 <- price6[[3]] p0 <- price6[[2]] q1 <- quantity6[[3]] q0 <- quantity6[[2]]  # Balance missing values for a Fisher index  fisher <- balanced(fisher_index) fisher(p1, p0, q1, replace(q0, 3, NA), na.rm = TRUE) #> [1] 0.9015449 fisher_index(p1[-3], p0[-3], q1[-3], q0[-3]) #> [1] 0.9015449  # Operators can be combined, but some care may be needed  x <- 1:6 w <- c(1:5, NA)  f <- factor(rep(letters[1:2], each = 3))  grouped(\\(x, w) balanced(fisher_mean)(x, w, na.rm = TRUE))(x, w, group = f) #> [1] 1.954017 1.954017 1.954017 4.499657 4.499657 4.499657 balanced(grouped(fisher_mean))(x, w, group = f, na.rm = TRUE) #> [1] 1.954017 1.954017 1.954017 4.499657 4.499657"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Percent-change contributions — contributions","title":"Percent-change contributions — contributions","text":"Calculate additive percent-change contributions generalized-mean price indexes, indexes nest two levels generalized means consisting outer generalized mean two inner generalized means (e.g., Fisher index).","code":""},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Percent-change contributions — contributions","text":"","code":"contributions(r)  arithmetic_contributions(x, w = NULL)  geometric_contributions(x, w = NULL)  harmonic_contributions(x, w = NULL)  nested_contributions(r1, r2, t = c(1, 1))  nested_contributions2(r1, r2, t = c(1, 1))  fisher_contributions(x, w1 = NULL, w2 = NULL)  fisher_contributions2(x, w1 = NULL, w2 = NULL)"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Percent-change contributions — contributions","text":"r finite number giving order generalized mean. x strictly positive numeric vector. w, w1, w2 strictly positive numeric vector weights, length x. default equally weight element x. r1 finite number giving order outer generalized mean. r2 pair finite numbers giving order inner generalized means. t pair strictly positive weights inner generalized means. default equal weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Percent-change contributions — contributions","text":"contributions() returns function: computes additive contribution element x index based generalized mean order r weights w. nested_contributions() nested_contributions2() return function: computes additive contribution element x generalized mean order r1 aggregates generalized-mean index order r2[1] weights w1 generalized-mean index order r2[2] weights w2. arithmetic_contributions(), geometric_contributions(), harmonic_contributions() return numeric vector, length x, giving contribution element x arithmetic, geometric, harmonic index. fisher_contributions() fisher_contributions2() return numeric vector, length x, giving contribution element x geometric mean aggregates arithmetic mean x weights w1 harmonic mean x weights w2.","code":"function(x, w = NULL){...} function(x, w1 = NULL, w2 = NULL){...}"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Percent-change contributions — contributions","text":"function contributions() simple wrapper transmute_weights(r, 1)() calculate (additive) percent-change contributions price index based generalized mean order r. returns function compute vector v(x, w) generalizes approach calculating percent-change contributions section 4.2 Balk (2008) using method Martin (2021). arithmetic_contributions(), geometric_contributions() harmonic_contributions() functions cover important cases (.e., r = 1, r = 0, r = -1). nested_contributions() nested_contributions2() functions analog contributions() index based nested generalized mean two levels, like Fisher index. return function calculates contribution element x generalized mean order r1 aggregates two generalized-mean indexes x orders r2, weights w1 w2. Unlike case generalized-mean index, several ways make contributions index based nested generalized means. nested_contributions() uses generalization algorithm section 6 Reinsdorf et al. (2002) Martin (2021). nested_contributions2() generalizes van IJzeren decomposition Fisher index (Balk, 2008, section 4.2.2) constructing weighted average contributions inner means approach Martin (2021). cases results broadly similar. fisher_contributions() fisher_contributions2() functions correspond nested_contributions(0, c(1, -1))() nested_contributions2(0, c(1, -1))(), appropriate calculating percent-change contributions Fisher index.","code":"generalized_mean(r)(x, w) - 1 == sum(v(x, w))"},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Percent-change contributions — contributions","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Hallerbach, W. G. (2005). alternative decomposition Fisher index. Economics Letters, 86(2):147–152 Martin, S. (2021). note general decompositions price indexes. Prices Analytical Series, Statistics Canada catalogue . 62F0014M. Statistics Canada, Ottawa. Reinsdorf, M. B., Diewert, W. E., Ehemann, C. (2002). Additive decompositions Fisher, Törnqvist geometric mean indexes. Journal Economic Social Measurement, 28(1-2):51–61. Webster, M. Tarnow-Mordi, R. C. (2019). Decomposing multilateral price indexes contributions individual commodities. Journal Official Statistics, 35(2):461–486.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/contributions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Percent-change contributions — contributions","text":"","code":"x <- 2:3  #---- Contributions for a geometric index ----  geometric_mean(x) - 1 # percent change in the Jevons index #> [1] 1.44949  geometric_contributions(x) #> [1] 0.5505103 0.8989795  all.equal(geometric_mean(x) - 1, sum(geometric_contributions(x))) #> [1] TRUE  # This works by first transmuting the weights in the geometric mean # into weights for an arithmetic mean, then finding the contributions # to the percent change  transmute_weights(0, 1)(x) * (x - 1) #> [1] 0.5505103 0.8989795  # Not the only way to calculate contributions  transmute2 <- function(x) {   m <- geometric_mean(x)   (m - 1) / log(m) * log(x) / (x - 1) / length(x) }  transmute2(x) * (x - 1) # not proportional to the method above #> [1] 0.5607392 0.8887506 all.equal(sum(transmute2(x) * (x - 1)), geometric_mean(x) - 1) #> [1] TRUE  # But these \"transmuted\" weights don't recover the geometric mean! # Not a particularly good way to calculate contributions  isTRUE(all.equal(   arithmetic_mean(x, transmute2(x)),   geometric_mean(x) )) #> [1] FALSE  # There are infinitely many ways to calculate contributions, but the # weights from transmute_weights(0, 1)() are the *unique* weights that # recover the geometric mean  perturb <- function(w, e) {   w + c(e, -e) / (x - 1) }  perturb(transmute2(x), 0.1) * (x - 1) #> [1] 0.6607392 0.7887506 all.equal(   sum(perturb(transmute2(x), 0.1) * (x - 1)),   geometric_mean(x) - 1 ) #> [1] TRUE isTRUE(all.equal(   arithmetic_mean(x, perturb(transmute2(x), 0.1)),   geometric_mean(x) )) #> [1] FALSE  #---- Contributions for a Fisher index ----  p1 <- price6[[2]] p0 <- price6[[1]] q1 <- quantity6[[2]] q0 <- quantity6[[1]]  # Percent-change contributions for the Fisher index in section 6 of # Reinsdorf et al. (2002)  (con <- fisher_contributions(   p1 / p0,   index_weights(\"Laspeyres\")(p0, q0),   index_weights(\"Paasche\")(p1, q1) )) #> [1]  0.01782904  0.18814917  0.05792820 -0.03414299  0.18217457 -0.01088796  all.equal(sum(con), fisher_index(p1, p0, q1, q0) - 1) #> [1] TRUE  # Not the only way  (con2 <- fisher_contributions2(   p1 / p0,   index_weights(\"Laspeyres\")(p0, q0),   index_weights(\"Paasche\")(p1, q1) )) #> [1]  0.01782865  0.18815627  0.05792735 -0.03414531  0.18217135 -0.01088828  all.equal(sum(con2), fisher_index(p1, p0, q1, q0) - 1) #> [1] TRUE  # The same as the van IJzeren decomposition in section 4.2.2 of # Balk (2008)  Qf <- quantity_index(fisher_index)(q1, q0, p1, p0) Ql <- quantity_index(laspeyres_index)(q1, q0, p0) wl <- scale_weights(index_weights(\"Laspeyres\")(p0, q0)) wp <- scale_weights(index_weights(\"HybridPaasche\")(p0, q1))  (Qf / (Qf + Ql) * wl + Ql / (Qf + Ql) * wp) * (p1 / p0 - 1) #> [1]  0.01782865  0.18815627  0.05792735 -0.03414531  0.18217135 -0.01088828  # Similar to the method in section 2 of Reinsdorf et al. (2002), # although those contributions aren't based on weights that sum to 1  Pf <- fisher_index(p1, p0, q1, q0) Pl <- laspeyres_index(p1, p0, q0)  (1 / (1 + Pf) * wl + Pl / (1 + Pf) * wp) * (p1 / p0 - 1) #> [1]  0.01760668  0.18766299  0.05803833 -0.03510719  0.18397180 -0.01112258  # Also similar to the decomposition by Hallerbach (2005), noting that # the Euler weights are close to unity  Pp <- paasche_index(p1, p0, q1)  (0.5 * sqrt(Pp / Pl) * wl + 0.5 * sqrt(Pl / Pp) * wp) * (p1 / p0 - 1) #> [1]  0.01781577  0.18809422  0.05791874 -0.03417605  0.18220228 -0.01089519  #---- Contributions for other types of indexes ----  # A function to get contributions for any superlative quadratic mean of # order 'r' index  superlative_contributions <- function(r) {   nested_contributions(0, c(r / 2, -r / 2)) }  # Can be used to decompose the implict Walsh index  superlative_contributions(1)(   p1 / p0,   index_weights(\"Laspeyres\")(p0, q0),   index_weights(\"Paasche\")(p1, q1) ) #> [1]  0.01797225  0.18686566  0.05817035 -0.03351992  0.18283997 -0.01079435  # Works for other types of indexes, like the harmonic # Laspeyres Paasche index  hlp_contributions <- nested_contributions(-1, c(1, -1)) hlp_contributions(   p1 / p0,   index_weights(\"Laspeyres\")(p0, q0),   index_weights(\"Paasche\")(p1, q1) ) #> [1]  0.01781416  0.18807725  0.05791352 -0.03417296  0.18218584 -0.01089421  # Or the AG mean index (tau = 0.25)  agmean_contributions <- nested_contributions(1, c(0, 1), c(0.25, 0.75)) agmean_contributions(   p1 / p0,   index_weights(\"Laspeyres\")(p0, q0),   index_weights(\"Laspeyres\")(p0, q0) ) #> [1]  0.02020872  0.18206588  0.06001941 -0.03256065  0.17841536 -0.01065698  # Or the Balk-Walsh index  bw_contributions <- nested_contributions(0, c(0.5, -0.5)) bw_contributions(p1 / p0) #> [1]  0.03304293  0.20895332  0.04762026 -0.06488592  0.06118424 -0.04046550"},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Extended mean — extended_mean","title":"Extended mean — extended_mean","text":"Calculate generalized logarithmic mean / extended mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extended mean — extended_mean","text":"","code":"extended_mean(r, s)  generalized_logmean(r)  logmean(a, b, tol = .Machine$double.eps^0.5)"},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extended mean — extended_mean","text":"r, s finite number giving order generalized logarithmic mean / extended mean. , b strictly positive numeric vector. tol tolerance used determine == b.","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extended mean — extended_mean","text":"generalized_logmean() extended_mean() return function: computes component-wise generalized logarithmic mean order r, extended mean orders r s, b. logmean() returns numeric vector, length max(length(), length(b)), giving component-wise logarithmic mean b.","code":"function(a, b, tol = .Machine$double.eps^0.5){...}"},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extended mean — extended_mean","text":"function extended_mean() returns function compute component-wise extended mean b orders r s. See Bullen (2003, p. 393) definition. also called difference mean, Stolarsky mean, extended mean-value mean. function generalized_logmean() returns function compute component-wise generalized logarithmic mean b order r. See Bullen (2003, p. 385) definition, https://en.wikipedia.org/wiki/Stolarsky_mean. generalized logarithmic mean special case extended mean, corresponding extended_mean(r, 1)(), commonly used price indexes. function logmean() returns ordinary component-wise logarithmic mean b, corresponds generalized_logmean(1)(). b strictly positive. enforced, results may make sense generalized logarithmic mean / extended mean defined. usual recycling rules apply b length. definition, generalized logarithmic mean / extended mean b == b. tol argument used test equality checking abs(- b) <= tol. default value .equal(). Setting tol = 0 tests exact equality, can give misleading results b computed values. cases useful multiply tol scale factor, max(abs(), abs(b)). often matter making price indexes, however, b usually around 1.","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extended mean — extended_mean","text":"generalized_logmean() can defined extended real line, r = -Inf / Inf returns pmin()/pmax(), agree definition , e.g., Bullen (2003). implemented, r must finite original formulation Stolarsky (1975).","code":""},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extended mean — extended_mean","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Bullen, P. S. (2003). Handbook Means Inequalities. Springer Science+Business Media. Stolarsky, K. B. (1975). Generalizations Logarithmic Mean. Mathematics Magazine, 48(2): 87-92.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/extended_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extended mean — extended_mean","text":"","code":"x <- 8:5 y <- 1:4  #---- Comparing logarithmic means and generalized means ----  # The arithmetic and geometric means are special cases of the # generalized logarithmic mean  all.equal(generalized_logmean(2)(x, y), (x + y) / 2) #> [1] TRUE all.equal(generalized_logmean(-1)(x, y), sqrt(x * y)) #> [1] TRUE  # The logarithmic mean lies between the arithmetic and geometric means # because the generalized logarithmic mean is increasing in r  all(logmean(x, y) < (x + y) / 2) &   all(logmean(x, y) > sqrt(x * y)) #> [1] TRUE  # The harmonic mean cannot be expressed as a logarithmic mean, but can # be expressed as an extended mean  all.equal(extended_mean(-2, -1)(x, y), 2 / (1 / x + 1 / y)) #> [1] TRUE  # The quadratic mean is also a type of extended mean  all.equal(extended_mean(2, 4)(x, y), sqrt(x^2 / 2 + y^2 / 2)) #> [1] TRUE  # As are heronian and centroidal means  all.equal(   extended_mean(0.5, 1.5)(x, y),   (x + sqrt(x * y) + y) / 3 ) #> [1] TRUE all.equal(   extended_mean(2, 3)(x, y),   2 / 3 * (x^2 + x * y + y^2) / (x + y) ) #> [1] TRUE  #---- Approximating the logarithmic mean ----  # The logarithmic mean can be approximated as a convex combination of # the arithmetic and geometric means that gives more weight to the # geometric mean  approx1 <- 1 / 3 * (x + y) / 2 + 2 / 3 * sqrt(x * y) approx2 <- ((x + y) / 2)^(1 / 3) * (sqrt(x * y))^(2 / 3)  approx1 - logmean(x, y) # always a positive approximation error #> [1] 1.932965e-02 3.260257e-03 3.420021e-04 3.852275e-06 approx2 - logmean(x, y) # a negative approximation error #> [1] -6.436118e-02 -1.212079e-02 -1.336412e-03 -1.537117e-05  # A better approximation  correction <- (log(x / y) / pi)^4 / 32 approx1 / (1 + correction) - logmean(x, y) #> [1] -8.576372e-04  1.064231e-04  2.148563e-05  2.877344e-07  #---- Some identities ----  # A useful identity for turning an additive change into a proportionate # change  all.equal(logmean(x, y) * log(x / y), x - y) #> [1] TRUE  # Works for other orders, too  r <- 2  all.equal(   generalized_logmean(r)(x, y)^(r - 1) * (r * (x - y)),   (x^r - y^r) ) #> [1] TRUE  # Some other identities  all.equal(   generalized_logmean(-2)(1, 2),   (harmonic_mean(1:2) * geometric_mean(1:2)^2)^(1 / 3) ) #> [1] TRUE  all.equal(   generalized_logmean(0.5)(1, 2),   (arithmetic_mean(1:2) + geometric_mean(1:2)) / 2 ) #> [1] TRUE  all.equal(   logmean(1, 2),   geometric_mean(1:2)^2 * logmean(1, 1 / 2) ) #> [1] TRUE  #---- Integral representations of the logarithmic mean ----  logmean(2, 3) #> [1] 2.466303  integrate(function(t) 2^(1 - t) * 3^t, 0, 1)$value #> [1] 2.466303 1 / integrate(function(t) 1 / (2 * (1 - t) + 3 * t), 0, 1)$value #> [1] 2.466303"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Factor weights — factor_weights","title":"Factor weights — factor_weights","text":"Factor weights turn generalized mean product product generalized means. Useful price-updating weights generalized-mean index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Factor weights — factor_weights","text":"","code":"factor_weights(r)  update_weights(x, w = NULL)"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Factor weights — factor_weights","text":"r finite number giving order generalized mean. x strictly positive numeric vector. w strictly positive numeric vector weights, length x. default equally weight element x.","code":""},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Factor weights — factor_weights","text":"factor_weights() return function: update_weights() returns numeric vector length x.","code":"function(x, w = NULL){...}"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Factor weights — factor_weights","text":"function factor_weights(r) returns function compute weights u(x, w) generalizes result section C.5 Chapter 9 PPI Manual chaining Young index, gives way chain generalized-mean price indexes time. Factoring weights r = 1 sometimes gets called price-updating weights; update_weights() simply calls factor_weights(1)(). Factoring weights return value length x, missing values x weights return NA. Unless values NA, however, result still satisfy identity na.rm = TRUE.","code":"generalized_mean(r)(x * y, w) ==   generalized_mean(r)(x, w) * generalized_mean(r)(y, u(x, w))"},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Factor weights — factor_weights","text":"ILO, IMF, OECD, UNECE, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/factor_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Factor weights — factor_weights","text":"","code":"x <- 1:3 y <- 4:6 w <- 3:1 # Factor the harmonic mean by chaining the calculation  harmonic_mean(x * y, w) #> [1] 5.966851 harmonic_mean(x, w) * harmonic_mean(y, factor_weights(-1)(x, w)) #> [1] 5.966851  # The common case of an arithmetic mean  arithmetic_mean(x * y, w) #> [1] 8.333333 arithmetic_mean(x, w) * arithmetic_mean(y, update_weights(x, w)) #> [1] 8.333333  # In cases where x and y have the same order, Chebyshev's # inequality implies that the chained calculation is too small  arithmetic_mean(x * y, w) >   arithmetic_mean(x, w) * arithmetic_mean(y, w) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":null,"dir":"Reference","previous_headings":"","what":"GEKS index — geks","title":"GEKS index — geks","text":"Calculate generalized inter-temporal GEKS price index rolling window.","code":""},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GEKS index — geks","text":"","code":"geks(f, r = 0)  tornqvist_geks(   p,   q,   period,   product,   window = nlevels(period),   n = window - 1L,   na.rm = FALSE )  fisher_geks(   p,   q,   period,   product,   window = nlevels(period),   n = window - 1L,   na.rm = FALSE )  walsh_geks(   p,   q,   period,   product,   window = nlevels(period),   n = window - 1L,   na.rm = FALSE )"},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GEKS index — geks","text":"f price index function uses information base current-period prices quantities, satisfies time-reversal test. Usually Törnqvist, Fisher, Walsh index. r finite number giving order generalized mean used average price indexes rolling window. default uses geometric mean. p numeric vector prices, length q. q numeric vector quantities, length p. period factor, something can coerced one, gives corresponding time period element p q. ordering time periods follows levels period agree cut(). product factor, something can coerced one, gives corresponding product identifier element p q. window positive integer giving length rolling window. default window encompasses periods period. Non-integers truncated towards zero. n positive integer giving length index series window, starting end window. example, 13 periods window, setting n = 1 gives index period 13. default gives index period window. Non-integers truncated towards zero. na.rm Passed f control missing values removed.","code":""},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GEKS index — geks","text":"geks() returns function: calculates period--period GEKS index desired index-number formula, returning list window named-numeric vector index values. tornqvist_geks(), fisher_geks(), walsh_geks() return list named numeric vector giving value respective period--period GEKS index window.","code":"function(p, q, period, product, window = nlevels(period), n =          window - 1, na.rm = FALSE){...}"},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"GEKS index — geks","text":"Like back_period(), multiple prices correspond period-product pair, back price point time always first price product previous period. Unlike bilateral index, however, duplicated period-product pairs can subtle implications multilateral index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"GEKS index — geks","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. Ivancic, L., Diewert, W. E., Fox, K. J. (2011). Scanner data, time aggregation construction price indexes. Journal Econometrics, 161(1): 24–35.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/geks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GEKS index — geks","text":"","code":"price <- 1:10 quantity <- 10:1 period <- rep(1:5, 2) product <- rep(letters[1:2], each = 5)  cumprod(tornqvist_geks(price, quantity, period, product)[[1]]) #>        2        3        4        5  #> 1.413257 1.835676 2.284565 2.789856   # Calculate the index over a rolling window  (tg <- tornqvist_geks(price, quantity, period, product, window = 3)) #> [[1]] #>        2        3  #> 1.391443 1.294442  #>  #> [[2]] #>        3        4  #> 1.292486 1.238393  #>  #> [[3]] #>        4        5  #> 1.238417 1.205921  #>   # Use a movement splice to combine the indexes in each window  splice_index(tg, 2) #>        2        3        4        5  #> 1.391443 1.801142 2.230521 2.689833   # ... or use a mean splice  splice_index(tg) #>        2        3        4        5  #> 1.391443 1.801142 2.228836 2.687826   #---- Missing data ----  quantity[2] <- NA  # Use all non-missing data  fisher_geks(price, quantity, period, product, na.rm = TRUE) #> [[1]] #>        2        3        4        5  #> 1.438137 1.234230 1.234212 1.216746  #>   # Remove records with any missing data  fg <- geks(balanced(fisher_index)) fg(price, quantity, period, product, na.rm = TRUE) #> [[1]] #>        2        3        4        5  #> 1.501481 1.148250 1.219688 1.199513  #>   #---- Make a Jevons GEKS index ----  jevons_geks <- geks(\\(p1, p0, ..., na.rm) jevons_index(p1, p0, na.rm)) jevons_geks(price, quantity, period, product) #> [[1]] #>        2        3        4        5  #> 1.527525 1.309307 1.224745 1.178511  #>"},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized mean — generalized_mean","title":"Generalized mean — generalized_mean","text":"Calculate weighted generalized mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized mean — generalized_mean","text":"","code":"generalized_mean(r)  arithmetic_mean(x, w = NULL, na.rm = FALSE)  geometric_mean(x, w = NULL, na.rm = FALSE)  harmonic_mean(x, w = NULL, na.rm = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized mean — generalized_mean","text":"r finite number giving order generalized mean. x strictly positive numeric vector. w strictly positive numeric vector weights, length x. default equally weight element x. na.rm missing values x w removed? default missing values x w return missing value.","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized mean — generalized_mean","text":"generalized_mean() returns function: computes generalized mean order r x weights w. arithmetic_mean(), geometric_mean(), harmonic_mean() return numeric value generalized means order 1, 0, -1.","code":"function(x, w = NULL, na.rm = FALSE){...}"},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generalized mean — generalized_mean","text":"function generalized_mean() returns function compute generalized mean x weights w exponent r (.e., \\(\\prod_{= 1}^{n} x_{}^{w_{}}\\) \\(r = 0\\) \\(\\left(\\sum_{= 1}^{n} w_{} x_{}^{r}\\right)^{1 / r}\\) otherwise). also called power mean, Hölder mean, \\(l_p\\) mean. See Bullen (2003, p. 175) definition, https://en.wikipedia.org/wiki/Generalized_mean. generalized mean solution optimal prediction problem: choose \\(m\\) minimize \\(\\sum_{= 1}^{n} w_{} \\left[\\log(x_{}) - \\log(m) \\right]^2\\) \\(r = 0\\), \\(\\sum_{= 1}^{n} w_{} \\left[x_{}^r - m^r \\right]^2\\) otherwise. functions arithmetic_mean(), geometric_mean(), harmonic_mean() compute arithmetic, geometric, harmonic (subcontrary) means, also known Pythagorean means. useful means making price indexes, correspond setting r = 1, r = 0, r = -1 generalized_mean(). x w strictly positive (finite), especially purpose making price index. enforced, results may make sense generalized mean defined. two exceptions . convention Hardy et al. (1952, p. 13) used cases x zeros: generalized mean 0 whenever w strictly positive r < 0. (analogous convention holds whenever least one element x Inf: generalized mean Inf whenever w strictly positive r > 0.) authors let w non-negative sum 1 (e.g., Sydsaeter et al., 2005, p. 47). w zeros, corresponding element x impact mean whenever x strictly positive. Unlike weighted.mean(), however, zeros w strong zeros, infinite values x propagate even corresponding elements w zero. weights scaled sum 1 satisfy definition generalized mean. certain price indexes weights scaled (e.g., Vartia-index); use sum() cases. underlying calculation returned generalized_mean() mostly identical weighted.mean(), one important exception: missing values weights treated differently missing values x. Setting na.rm = TRUE drops missing values x w, just x. ensures certain useful identities satisfied missing values x. cases arithmetic_mean() drop-replacement weighted.mean().","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generalized mean — generalized_mean","text":"generalized_mean() can defined extended real line, r = -Inf / Inf returns min()/max(), agree definition , e.g., Bullen (2003). implemented, r must finite. number existing functions calculating unweighted geometric harmonic means, namely geometric.mean() harmonic.mean() functions psych package, geomean() function FSA package, GMean() HMean() functions DescTools package, geoMean() function EnvStats package. Similarly, ci_generalized_mean() function Compind package calculates unweighted generalized mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generalized mean — generalized_mean","text":"Bullen, P. S. (2003). Handbook Means Inequalities. Springer Science+Business Media. Fisher, . (1922). Making Index Numbers. Houghton Mifflin Company. Hardy, G., Littlewood, J. E., Polya, G. (1952). Inequalities (2nd edition). Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. Lord, N. (2002). Smaller Spread Always Mean Larger Product? Mathematical Gazette, 86(506): 273-274. Sydsaeter, K., Strom, ., Berck, P. (2005). Economists' Mathematical Manual (4th edition). Springer.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/generalized_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized mean — generalized_mean","text":"","code":"x <- 1:3 w <- c(0.25, 0.25, 0.5)  #---- Common generalized means ----  # Arithmetic mean  arithmetic_mean(x, w) # same as weighted.mean(x, w) #> [1] 2.25  # Geometric mean  geometric_mean(x, w) # same as prod(x^w) #> [1] 2.059767  # Harmonic mean  harmonic_mean(x, w) # same as 1 / weighted.mean(1 / x, w) #> [1] 1.846154  # Quadratic mean / root mean square  generalized_mean(2)(x, w) #> [1] 2.397916  # Cubic mean # Notice that this is larger than the other means so far because # the generalized mean is increasing in r  generalized_mean(3)(x, w) #> [1] 2.506649  #---- Comparing the Pythagorean means ----  # The dispersion between the arithmetic, geometric, and harmonic # mean usually increases as the variance of 'x' increases  x <- c(1, 3, 5) y <- c(2, 3, 4)  var(x) > var(y) #> [1] TRUE  arithmetic_mean(x) - geometric_mean(x) #> [1] 0.5337879 arithmetic_mean(y) - geometric_mean(y) #> [1] 0.1155009  geometric_mean(x) - harmonic_mean(x) #> [1] 0.5096903 geometric_mean(y) - harmonic_mean(y) #> [1] 0.1152684  # But the dispersion between these means is only bounded by the # variance (Bullen, 2003, p. 156)  arithmetic_mean(x) - geometric_mean(x) >= 2 / 3 * var(x) / (2 * max(x)) #> [1] TRUE arithmetic_mean(x) - geometric_mean(x) <= 2 / 3 * var(x) / (2 * min(x)) #> [1] TRUE  # Example by Lord (2002) where the dispersion decreases as the variance # increases, counter to the claims by Fisher (1922, p. 108) and the # CPI manual (par. 1.14)  x <- (5 + c(sqrt(5), -sqrt(5), -3)) / 4 y <- (16 + c(7 * sqrt(2), -7 * sqrt(2), 0)) / 16  var(x) > var(y) #> [1] TRUE  arithmetic_mean(x) - geometric_mean(x) #> [1] 0.145012 arithmetic_mean(y) - geometric_mean(y) #> [1] 0.1485894  geometric_mean(x) - harmonic_mean(x) #> [1] 0.104988 geometric_mean(y) - harmonic_mean(y) #> [1] 0.1439479  # The \"bias\" in the arithmetic and harmonic indexes is also smaller in # this case, counter to the claim by Fisher (1922, p. 108)  arithmetic_mean(x) * arithmetic_mean(1 / x) - 1 #> [1] 0.3333333 arithmetic_mean(y) * arithmetic_mean(1 / y) - 1 #> [1] 0.4135021  harmonic_mean(x) * harmonic_mean(1 / x) - 1 #> [1] -0.25 harmonic_mean(y) * harmonic_mean(1 / y) - 1 #> [1] -0.2925373  #---- Missing values ----  w[2] <- NA  arithmetic_mean(x, w, na.rm = TRUE) # drop the second observation #> [1] 0.936339 weighted.mean(x, w, na.rm = TRUE) # still returns NA #> [1] NA"},{"path":"https://marberts.github.io/gpindex/reference/gpindex-package.html","id":null,"dir":"Reference","previous_headings":"","what":"gpindex: Generalized Price and Quantity Indexes — gpindex-package","title":"gpindex: Generalized Price and Quantity Indexes — gpindex-package","text":"Tools build work bilateral generalized-mean price indexes (extension quantity indexes), indexes composed generalized-mean indexes (e.g., superlative quadratic-mean indexes, GEKS). Covers core mathematical machinery making bilateral price indexes, computing price relatives, detecting outliers, decomposing indexes, wrappers common (many uncommon) index-number formulas. Implements extends many methods Balk (2008, doi:10.1017/CBO9780511720758 ), von der Lippe (2007, doi:10.3726/978-3-653-01120-3 ), CPI manual (2020, doi:10.5089/9781484354841.069 ).","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/gpindex-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"gpindex: Generalized Price and Quantity Indexes — gpindex-package","text":"Maintainer: Steve Martin marberts@protonmail.com (ORCID) [copyright holder]","code":""},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":null,"dir":"Reference","previous_headings":"","what":"Grouped operator — grouped","title":"Grouped operator — grouped","text":"Make function applicable grouped data.","code":""},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Grouped operator — grouped","text":"","code":"grouped(f, ...)"},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Grouped operator — grouped","text":"f function. ... Deprecated. Additional arguments f treated grouped.","code":""},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Grouped operator — grouped","text":"function like f new argument group. accepts factor split arguments f groups applying f group combining results. similar ave(), general.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/grouped.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Grouped operator — grouped","text":"","code":"p1 <- price6[[3]] p0 <- price6[[2]] q1 <- quantity6[[3]] q0 <- quantity6[[2]]  # Calculate Tornqvist weights for two groups  f <- factor(rep(letters[1:2], each = 3)) tornqvist_weights <- grouped(index_weights(\"Tornqvist\")) tornqvist_weights(p1, p0, q1, q0, group = f) #> [1] 0.18247009 0.33481172 0.48271819 0.12865397 0.81833234 0.05301369  # Calculate a mean like ave(), but with weights  x <- 1:6 w <- c(1:5, NA) grouped_mean <- grouped(\\(x, w) geometric_mean(x, w, na.rm = TRUE)) grouped_mean(x, w, group = f) #> [1] 2.182247 2.182247 2.182247 4.527921 4.527921 4.527921  # Redistribute weights  w1 <- c(2, 4) w2 <- 1:6  harmonic_mean(mapply(harmonic_mean, split(x, f), split(w2, f)), w1) #> [1] 3.333333  wr <- grouped(scale_weights)(w2, group = f) * w1[f] harmonic_mean(x, wr) #> [1] 3.333333"},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Index weights — index_weights","title":"Index weights — index_weights","text":"Calculate weights variety different price indexes.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Index weights — index_weights","text":"","code":"index_weights(   type = c(\"Carli\", \"Jevons\", \"Coggeshall\", \"Dutot\", \"Laspeyres\", \"HybridLaspeyres\",     \"LloydMoulton\", \"Palgrave\", \"Paasche\", \"HybridPaasche\", \"Drobisch\", \"Unnamed\",     \"Tornqvist\", \"Walsh1\", \"Walsh2\", \"MarshallEdgeworth\", \"GearyKhamis\", \"Vartia1\",     \"MontgomeryVartia\", \"Vartia2\", \"SatoVartia\", \"Theil\", \"Rao\", \"Lowe\", \"Young\",     \"HybridCSWD\") )"},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Index weights — index_weights","text":"type name index. See details possible types indexes.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Index weights — index_weights","text":"function current base period prices/quantities calculates relevant weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Index weights — index_weights","text":"index_weights() function returns function calculate weights variety price indexes. Weights following types indexes can calculated. Carli / Jevons / Coggeshall Dutot Laspeyres / Lloyd-Moulton Hybrid Laspeyres (use harmonic mean) Paasche / Palgrave Hybrid Paasche (use arithmetic mean) Törnqvist / Unnamed Drobisch Walsh-(arithmetic Walsh index) Walsh-II (geometric Walsh index) Marshall-Edgeworth Geary-Khamis Montgomery-Vartia / Vartia-Sato-Vartia / Vartia-II Theil Rao Lowe Young Hybrid-CSWD weights need sum 1, normalization always appropriate (.e., Vartia-weights).","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Index weights — index_weights","text":"Naming indexes weights generally follows CPI manual (2020), Balk (2008), von der Lippe (2007), Selvanathan Rao (1994). several cases two names correspond weights (e.g., Paasche Palgrave, Sato-Vartia Vartia-II). calculations given examples.","code":""},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Index weights — index_weights","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang. Selvanathan, E. . Rao, D. S. P. (1994). Index Numbers: Stochastic Approach. MacMillan.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/index_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Index weights — index_weights","text":"","code":"p0 <- price6[[2]] p1 <- price6[[3]] q0 <- quantity6[[2]] q1 <- quantity6[[3]] pb <- price6[[1]] qb <- quantity6[[1]]  #---- Making the weights for different indexes ----  # Explicit calculation for each of the different weights # Carli/Jevons/Coggeshall  all.equal(index_weights(\"Carli\")(p1), rep(1, length(p0))) #> [1] TRUE  # Dutot  all.equal(index_weights(\"Dutot\")(p0), p0) #> [1] TRUE  # Laspeyres / Lloyd-Moulton  all.equal(index_weights(\"Laspeyres\")(p0, q0), p0 * q0) #> [1] TRUE  # Hybrid Laspeyres  all.equal(index_weights(\"HybridLaspeyres\")(p1, q0), p1 * q0) #> [1] TRUE  # Paasche / Palgrave  all.equal(index_weights(\"Paasche\")(p1, q1), p1 * q1) #> [1] TRUE  # Hybrid Paasche  all.equal(index_weights(\"HybridPaasche\")(p0, q1), p0 * q1) #> [1] TRUE  # Tornqvist / Unnamed  all.equal(   index_weights(\"Tornqvist\")(p1, p0, q1, q0),   0.5 * p0 * q0 / sum(p0 * q0) + 0.5 * p1 * q1 / sum(p1 * q1) ) #> [1] TRUE  # Drobisch  all.equal(   index_weights(\"Drobisch\")(p1, p0, q1, q0),   0.5 * p0 * q0 / sum(p0 * q0) + 0.5 * p0 * q1 / sum(p0 * q1) ) #> [1] TRUE  # Walsh-I  all.equal(   index_weights(\"Walsh1\")(p0, q1, q0),   p0 * sqrt(q0 * q1) ) #> [1] TRUE  # Marshall-Edgeworth  all.equal(   index_weights(\"MarshallEdgeworth\")(p0, q1, q0),   p0 * (q0 + q1) ) #> [1] TRUE  # Geary-Khamis  all.equal(   index_weights(\"GearyKhamis\")(p0, q1, q0),   p0 / (1 / q0 + 1 / q1) ) #> [1] TRUE  # Montgomery-Vartia / Vartia-I  all.equal(   index_weights(\"MontgomeryVartia\")(p1, p0, q1, q0),   logmean(p0 * q0, p1 * q1) / logmean(sum(p0 * q0), sum(p1 * q1)) ) #> [1] TRUE  # Sato-Vartia / Vartia-II  all.equal(   index_weights(\"SatoVartia\")(p1, p0, q1, q0),   logmean(p0 * q0 / sum(p0 * q0), p1 * q1 / sum(p1 * q1)) ) #> [1] TRUE  # Walsh-II  all.equal(   index_weights(\"Walsh2\")(p1, p0, q1, q0),   sqrt(p0 * q0 * p1 * q1) ) #> [1] TRUE  # Theil  all.equal(index_weights(\"Theil\")(p1, p0, q1, q0), {   w0 <- scale_weights(p0 * q0)   w1 <- scale_weights(p1 * q1)   (w0 * w1 * (w0 + w1) / 2)^(1 / 3) }) #> [1] TRUE  # Rao  all.equal(index_weights(\"Rao\")(p1, p0, q1, q0), {   w0 <- scale_weights(p0 * q0)   w1 <- scale_weights(p1 * q1)   w0 * w1 / (w0 + w1) }) #> [1] TRUE  # Lowe  all.equal(index_weights(\"Lowe\")(p0, qb), p0 * qb) #> [1] TRUE  # Young  all.equal(index_weights(\"Young\")(pb, qb), pb * qb) #> [1] TRUE  # Hybrid CSWD (to approximate a CSWD index)  all.equal(index_weights(\"HybridCSWD\")(p1, p0), sqrt(p0 / p1)) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Lehmer mean — lehmer_mean","title":"Lehmer mean — lehmer_mean","text":"Calculate weighted Lehmer mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lehmer mean — lehmer_mean","text":"","code":"lehmer_mean(r)  contraharmonic_mean(x, w = NULL, na.rm = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lehmer mean — lehmer_mean","text":"r finite number giving order Lehmer mean. x strictly positive numeric vector. w strictly positive numeric vector weights, length x. default equally weight element x. na.rm missing values x w removed? default missing values x w return missing value.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lehmer mean — lehmer_mean","text":"lehmer_mean() returns function: computes Lehmer mean order r x weights w. contraharmonic_mean() returns numeric value Lehmer mean order 2.","code":"function(x, w = NULL, na.rm = FALSE){...}"},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Lehmer mean — lehmer_mean","text":"function lehmer_mean() returns function compute Lehmer mean order r x weights w, calculated arithmetic mean x weights \\(wx^{r-1}\\). also called counter-harmonic mean generalized anti-harmonic mean. See Bullen (2003, p. 245) definition, https://en.wikipedia.org/wiki/Lehmer_mean. Lehmer mean order 2 sometimes called contraharmonic (anti-harmonic) mean. function contraharmonic_mean() simply calls lehmer_mean(2)(). Like generalized mean, contraharmonic mean solution optimal prediction problem: choose \\(m\\) minimize \\(\\sum_{= 1}^{n} w_{} \\left(\\frac{x_{}}{m} - 1 \\right)^2\\). Lehmer mean order -1 similar interpretation, replacing \\(\\frac{x_{}}{m}\\) \\(\\frac{m}{x_{}}\\), together bound harmonic arithmetic means. Lehmer mean alternative generalized mean generalizes Pythagorean means. function lehmer_mean(1)() identical arithmetic_mean(), lehmer_mean(0)() identical harmonic_mean(), lehmer_mean(0.5)() identical geometric_mean() two values weights. See von der Lippe (2015) details use means making price indexes.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Lehmer mean — lehmer_mean","text":"lehmer_mean() can defined extended real line, r = -Inf / Inf returns min()/max(), agree definition , e.g., Bullen (2003). implemented, r must finite.","code":""},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Lehmer mean — lehmer_mean","text":"Bullen, P. S. (2003). Handbook Means Inequalities. Springer Science+Business Media. Lehmer, D. H. (1971). Compounding Certain Means. Journal Mathematical Analysis Applications, 36(1): 183-200. von der Lippe, P. (2015). Generalized Statistical Means New Price Index Formulas, Notes unexplored index formulas, interpretations generalizations. Munich Personal RePEc Archive paper . 64952.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/lehmer_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lehmer mean — lehmer_mean","text":"","code":"x <- 2:3 w <- c(0.25, 0.75)  #---- The Pythagorean means are special cases of the Lehmer mean ----  all.equal(lehmer_mean(1)(x, w), arithmetic_mean(x, w)) #> [1] TRUE all.equal(lehmer_mean(0)(x, w), harmonic_mean(x, w)) #> [1] TRUE all.equal(lehmer_mean(0.5)(x), geometric_mean(x)) #> [1] TRUE  #---- Comparing Lehmer means and generalized means ----  # When r < 1, the generalized mean is larger than the corresponding # Lehmer mean  lehmer_mean(-1)(x, w) < generalized_mean(-1)(x, w) #> [1] TRUE  # The reverse is true when r > 1  lehmer_mean(3)(x, w) > generalized_mean(3)(x, w) #> [1] TRUE  # This implies the contraharmonic mean is larger than the quadratic # mean, and therefore the Pythagorean means  contraharmonic_mean(x, w) > arithmetic_mean(x, w) #> [1] TRUE contraharmonic_mean(x, w) > geometric_mean(x, w) #> [1] TRUE contraharmonic_mean(x, w) > harmonic_mean(x, w) #> [1] TRUE  # ... and the logarithmic mean  contraharmonic_mean(2:3) > logmean(2, 3) #> [1] TRUE  # The difference between the arithmetic mean and contraharmonic mean # is proportional to the variance of x  weighted_var <- function(x, w) {   arithmetic_mean((x - arithmetic_mean(x, w))^2, w) }  arithmetic_mean(x, w) + weighted_var(x, w) / arithmetic_mean(x, w) #> [1] 2.818182 contraharmonic_mean(x, w) #> [1] 2.818182  #---- Changing the order of the mean ----  # It is easy to modify the weights to turn a Lehmer mean of order r # into a Lehmer mean of order s because the Lehmer mean can be # expressed as an arithmetic mean  r <- 2 s <- -3 lehmer_mean(r)(x, w) #> [1] 2.818182 lehmer_mean(s)(x, w * x^(r - 1) / x^(s - 1)) #> [1] 2.818182  # The weights can also be modified to turn a Lehmer mean of order r # into a generalized mean of order s  lehmer_mean(r)(x, w) #> [1] 2.818182 generalized_mean(s)(x, transmute_weights(1, s)(x, w * x^(r - 1))) #> [1] 2.818182  # ... and vice versa  lehmer_mean(r)(x, transmute_weights(s, 1)(x, w) / x^(r - 1)) #> [1] 2.568312 generalized_mean(s)(x, w) #> [1] 2.568312  #---- Percent-change contributions ----  # Percent-change contributions for a price index based on the Lehmer # mean are easy to calculate  scale_weights(w * x^(r - 1)) * (x - 1) #> [1] 0.1818182 1.6363636"},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Nested generalized mean — nested_mean","title":"Nested generalized mean — nested_mean","text":"Calculate (outer) generalized mean two (inner) generalized means (.e., crossing generalized means).","code":""},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nested generalized mean — nested_mean","text":"","code":"nested_mean(r1, r2, t = c(1, 1))  fisher_mean(x, w1 = NULL, w2 = NULL, na.rm = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nested generalized mean — nested_mean","text":"r1 finite number giving order outer generalized mean. r2 pair finite numbers giving order inner generalized means. t pair strictly positive weights inner generalized means. default equal weights. x strictly positive numeric vector. w1, w2 strictly positive numeric vector weights, length x. default equally weight element x. na.rm missing values x, w1, w2 removed? default missing values x, w1, w2 return missing value.","code":""},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nested generalized mean — nested_mean","text":"nested_mean() returns function: computes generalized mean order r1 generalized mean order r2[1] x weights w1 generalized mean order r2[2] x weights w2. fisher_mean() returns numeric value geometric mean arithmetic harmonic means (.e., r1 = 0 r2 = c(1, -1)).","code":"function(x, w1 = NULL, w2 = NULL, na.rm = FALSE){...}"},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Nested generalized mean — nested_mean","text":"ambiguity remove missing values w1 w2 na.rm = TRUE. approach remove missing values calculating inner means individually, rather removing missing values prior calculations. means different number data points used calculate inner means. Use balanced() operator balance missing values across w1 w2 prior calculations.","code":""},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Nested generalized mean — nested_mean","text":"Diewert, W. E. (1976). Exact superlative index numbers. Journal Econometrics, 4(2): 114–145. ILO, IMF, OECD, UNECE, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund. Lent, J. Dorfman, . H. (2009). Using weighted average base period price indexes approximate superlative index. Journal Official Statistics, 25(1):139–149.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/nested_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nested generalized mean — nested_mean","text":"","code":"x <- 1:3 w1 <- 4:6 w2 <- 7:9  #---- Making superlative indexes ----  # A function to make the superlative quadratic mean price index by # Diewert (1976) as a product of generalized means  quadratic_mean_index <- function(r) nested_mean(0, c(r / 2, -r / 2))  quadratic_mean_index(2)(x, w1, w2) #> [1] 1.912366  # The arithmetic AG mean index by Lent and Dorfman (2009)  agmean_index <- function(tau) nested_mean(1, c(0, 1), c(tau, 1 - tau))  agmean_index(0.25)(x, w1, w1) #> [1] 2.088801  #---- Walsh index ----  # The (arithmetic) Walsh index is the implicit price index when using a # superlative quadratic mean quantity index of order 1  p1 <- price6[[2]] p0 <- price6[[1]] q1 <- quantity6[[2]] q0 <- quantity6[[1]]  walsh <- quadratic_mean_index(1)  sum(p1 * q1) / sum(p0 * q0) / walsh(q1 / q0, p0 * q0, p1 * q1) #> [1] 1.401718  sum(p1 * sqrt(q1 * q0)) / sum(p0 * sqrt(q1 * q0)) #> [1] 1.401718  # Counter to the PPI manual (par. 1.105), it is not a superlative # quadratic mean price index of order 1  walsh(p1 / p0, p0 * q0, p1 * q1) #> [1] 1.401534  # That requires using the average value share as weights  walsh_weights <- sqrt(scale_weights(p0 * q0) * scale_weights(p1 * q1)) walsh(p1 / p0, walsh_weights, walsh_weights) #> [1] 1.401718  #---- Missing values ----  x[1] <- NA w1[2] <- NA  fisher_mean(x, w1, w2, na.rm = TRUE) #> [1] 2.699206  # Same as using obs 2 and 3 in an arithmetic mean, and obs 3 in a # harmonic mean  geometric_mean(c(   arithmetic_mean(x, w1, na.rm = TRUE),   harmonic_mean(x, w2, na.rm = TRUE) )) #> [1] 2.699206  # Use balanced() to use only obs 3 in both inner means  balanced(fisher_mean)(x, w1, w2, na.rm = TRUE) #> [1] 3"},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier detection for price relatives — outliers","title":"Outlier detection for price relatives — outliers","text":"Standard cutoff-based methods detecting outliers price relatives.","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier detection for price relatives — outliers","text":"","code":"quartile_method(x, cu = 2.5, cl = cu, a = 0, type = 7)  resistant_fences(x, cu = 2.5, cl = cu, a = 0, type = 7)  robust_z(x, cu = 2.5, cl = cu)  fixed_cutoff(x, cu = 2.5, cl = 1/cu)  tukey_algorithm(x, cu = 2.5, cl = cu, type = 7)  hb_transform(x)"},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier detection for price relatives — outliers","text":"x strictly positive numeric vector price relatives. can made , e.g., back_period(). cu, cl numeric vector, something can coerced one, giving upper lower cutoffs element x. Recycled length x. numeric vector, something can coerced one, 0 1 giving scale factor median establish minimum dispersion quartiles element x. default set minimum dispersion. Recycled length x. type See quantile().","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier detection for price relatives — outliers","text":"logical vector, length x, TRUE corresponding element x identified outlier, FALSE otherwise.","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Outlier detection for price relatives — outliers","text":"functions constructs interval form \\([b_l(x) - c_l \\times l(x), b_u(x) + c_u \\times u(x)]\\) assigns value x TRUE value belong interval, FALSE otherwise. methods differ construct values \\(b_l(x)\\), \\(b_u(x)\\), \\(l(x)\\), \\(u(x)\\). missing values x ignored calculating cutoffs, return NA. fixed cutoff method simplest, just uses interval \\([c_l, c_u]\\). quartile method Tukey algorithm described paragraphs 5.113 5.135 CPI manual (2020), well Rais (2008) Hutton (2008). resistant fences method alternative quartile method, described Rais (2008) Hutton (2008). Quantile-based methods often identify price relatives outliers distribution concentrated around 1; setting > 0 puts floor minimum dispersion quantiles fraction median. See references details. robust Z-score usual method identify relatives (asymmetric) tails distribution, simply replacing mean median, standard deviation median absolute deviation. methods often assume price relatives symmetrically distributed (Gaussian). distribution price relatives often long right tail, natural logarithm can used transform price relative identifying outliers (sometimes assumption price relatives distributed log-normal). Hidiroglou-Berthelot transformation another approach, described CPI manual (par. 5.124). (Sometimes transformed price relatives multiplied \\(\\max(p_1, p_0)^u\\), \\(0 \\le u \\le 1\\), products larger price get flagged outliers (par. 5.128).)","code":""},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outlier detection for price relatives — outliers","text":"Hutton, H. (2008). Dynamic outlier detection price index surveys. Proceedings Survey Methods Section: Statistical Society Canada Annual Meeting. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. Rais, S. (2008). Outlier detection Consumer Price Index. Proceedings Survey Methods Section: Statistical Society Canada Annual Meeting.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/outliers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier detection for price relatives — outliers","text":"","code":"set.seed(1234)  x <- rlnorm(10)  fixed_cutoff(x) #>  [1]  TRUE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE robust_z(x) #>  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE quartile_method(x) #>  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE resistant_fences(x) # always identifies fewer outliers than above #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE tukey_algorithm(x) #>  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  log(x) #>  [1] -1.2070657  0.2774292  1.0844412 -2.3456977  0.4291247  0.5060559 #>  [7] -0.5747400 -0.5466319 -0.5644520 -0.8900378 hb_transform(x) #>  [1] -0.918538151  1.300051411  4.154877789 -4.990623335  1.676813038 #>  [6]  1.890871823 -0.019423964  0.008909836 -0.008989935 -0.397291327  # Works the same for grouped data  f <- c(\"a\", \"b\", \"a\", \"a\", \"b\", \"b\", \"b\", \"a\", \"a\", \"b\") grouped(quartile_method)(x, group = f) #>  [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE"},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Sample price/quantity data — price_data","title":"Sample price/quantity data — price_data","text":"Prices quantities six products five periods.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sample price/quantity data — price_data","text":"data frame 6 rows 5 columns, row corresponding product column corresponding time period.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Sample price/quantity data — price_data","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. ILO, IMF, OECD, UNECE, World Bank. (2004). Producer Price Index Manual: Theory Practice. International Monetary Fund.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sample price/quantity data — price_data","text":"Adapted tables 3.1 3.2 Balk (2008), adapted tables 19.1 19.2 PPI manual.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sample price/quantity data — price_data","text":"","code":"# Recreate tables 3.4, 3.6, and 3.12 from Balk (2008)  index_formulas <- function(p1, p0, q1, q0) {   c(     harmonic_laspeyres = harmonic_index(\"Laspeyres\")(p1, p0, q0),     geometric_laspeyres = geometric_index(\"Laspeyres\")(p1, p0, q0),     laspeyres = arithmetic_index(\"Laspeyres\")(p1, p0, q0),     paasche = harmonic_index(\"Paasche\")(p1, p0, q1),     geometric_paasche = geometric_index(\"Paasche\")(p1, p0, q1),     palgrave = arithmetic_index(\"Palgrave\")(p1, p0, q1),     fisher = fisher_index(p1, p0, q1, q0),     tornqvist = geometric_index(\"Tornqvist\")(p1, p0, q1, q0),     marshall_edgeworth = arithmetic_index(\"MarshallEdgeworth\")(p1, p0, q1, q0),     walsh1 = arithmetic_index(\"Walsh1\")(p1, p0, q1, q0),     vartia2 = geometric_index(\"Vartia2\")(p1, p0, q1, q0),     vartia1 = geometric_index(\"Vartia1\")(p1, p0, q1, q0),     stuvel = stuvel_index(2, 2)(p1, p0, q1, q0)   ) }  round(t(mapply(index_formulas, price6, price6[1], quantity6, quantity6[1])), 4) #>    harmonic_laspeyres geometric_laspeyres laspeyres paasche geometric_paasche #> t1             1.0000              1.0000     1.000  1.0000            1.0000 #> t2             1.2542              1.3300     1.420  1.3824            1.4846 #> t3             1.1346              1.2523     1.345  1.2031            1.3268 #> t4             0.8732              1.1331     1.355  1.0209            1.3282 #> t5             0.5556              1.0999     1.440  0.7968            1.4153 #>    palgrave fisher tornqvist marshall_edgeworth walsh1 vartia2 vartia1 stuvel #> t1   1.0000 1.0000    1.0000             1.0000 1.0000  1.0000  1.0000 1.0000 #> t2   1.6096 1.4011    1.4052             1.4010 1.4017  1.4018  1.4024 1.4042 #> t3   1.4161 1.2721    1.2890             1.2656 1.2850  1.2897  1.2907 1.2742 #> t4   1.5317 1.1762    1.2268             1.1438 1.2193  1.2335  1.2392 1.1551 #> t5   1.6720 1.0712    1.2477             0.9801 1.1850  1.2540  1.2678 0.9770"},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Price indexes — price_indexes","title":"Price indexes — price_indexes","text":"Calculate variety price indexes using information prices quantities two points time.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Price indexes — price_indexes","text":"","code":"arithmetic_index(type)  geometric_index(type)  harmonic_index(type)  laspeyres_index(p1, p0, q0, na.rm = FALSE)  paasche_index(p1, p0, q1, na.rm = FALSE)  jevons_index(p1, p0, na.rm = FALSE)  lowe_index(p1, p0, qb, na.rm = FALSE)  young_index(p1, p0, pb, qb, na.rm = FALSE)  fisher_index(p1, p0, q1, q0, na.rm = FALSE)  hlp_index(p1, p0, q1, q0, na.rm = FALSE)  lm_index(elasticity)  cswd_index(p1, p0, na.rm = FALSE)  cswdb_index(p1, p0, q1, q0, na.rm = FALSE)  bw_index(p1, p0, na.rm = FALSE)  stuvel_index(a, b)  arithmetic_agmean_index(elasticity)  geometric_agmean_index(elasticity)  lehr_index(p1, p0, q1, q0, na.rm = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Price indexes — price_indexes","text":"type name index. See details possible types indexes. p1 Current-period prices. p0 Base-period prices. q0 Base-period quantities. na.rm missing values removed? default missing values prices quantities return missing value. q1 Current-period quantities. qb Period-b quantities Lowe/Young index. pb Period-b prices Lowe/Young index. elasticity elasticity substitution Lloyd-Moulton AG mean indexes. , b Parameters generalized Stuvel index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Price indexes — price_indexes","text":"arithmetic_index(), geometric_index(), harmonic_index(), stuvel_index() return function compute relevant price indexes; lm_index(), arithmetic_agmean_index(), geometric_agmean_index() return function calculate relevant index given elasticity substitution. others return numeric value giving change price base period current period.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Price indexes — price_indexes","text":"arithmetic_index(), geometric_index(), harmonic_index() functions return function calculate given type arithmetic, geometric (logarithmic), harmonic index. Together, functions produce functions calculate following indexes. Arithmetic indexes Carli Dutot Laspeyres Palgrave Unnamed index (arithmetic mean Laspeyres Palgrave) Drobisch (Sidgwick, arithmetic mean Laspeyres Paasche) Walsh-(arithmetic Walsh) Marshall-Edgeworth Geary-Khamis Lowe Young Hybrid-CSWD Geometric indexes Jevons Geometric Laspeyres (Jöhr) Geometric Paasche Geometric Young Törnqvist (Törnqvist-Theil) Montgomery-Vartia / Vartia-Sato-Vartia / Vartia-II Walsh-II (geometric Walsh) Theil Rao Harmonic indexes Coggeshall (equally weighted harmonic index) Paasche Harmonic Laspeyres Harmonic Young Along lm_index() function calculate Lloyd-Moulton index, just convenient wrappers generalized_mean() index_weights(). Laspeyres, Paasche, Jevons, Lowe, Young indexes among common price indexes, get functions. laspeyres_index(), lowe_index(), young_index() functions correspond setting appropriate type arithmetic_index(); paasche_index() jevons_index() instead come harmonic_index() geometric_index() functions. addition indexes, also functions calculating variety indexes based nested generalized means. Fisher index geometric mean arithmetic Laspeyres Paasche indexes; Harmonic Laspeyres Paasche (Harmonic Paasche Laspeyres) index harmonic analog Fisher index (8054 Fisher's list). Carruthers-Sellwood-Ward-Dalen Carruthers-Sellwood-Ward-Dalen-Balk indexes sample analogs Fisher index; Balk-Walsh index sample analog Walsh index. AG mean index arithmetic geometric mean geometric arithmetic Laspeyres indexes, weighted elasticity substitution. stuvel_index() function returns function calculate Stuvel index given parameters. Lehr index alternative Geary-Khamis index, implicit price index Fisher's index 4153.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Price indexes — price_indexes","text":"different ways deal missing values price index, care taken relying functions remove missing values. Setting na.rm = TRUE removes price relatives missing information, either missing price missing weight, using available non-missing information make weights. Certain properties index-number formula may work expected removing missing values ambiguity remove missing values weights (, e.g., Törnqvist Sato-Vartia index). balanced() operator may helpful, balances removal missing values across prices quantities prior making weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Price indexes — price_indexes","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Fisher, . (1922). Making Index Numbers. Houghton Mifflin Company. IMF, ILO, Eurostat, UNECE, OECD, World Bank. (2020). Consumer Price Index Manual: Concepts Methods. International Monetary Fund. von der Lippe, P. (2007). Index Theory Price Statistics. Peter Lang. von der Lippe, P. (2015). Generalized Statistical Means New Price Index Formulas, Notes unexplored index formulas, interpretations generalizations. Munich Personal RePEc Archive paper . 64952. Selvanathan, E. . Rao, D. S. P. (1994). Index Numbers: Stochastic Approach. MacMillan.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/price_indexes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Price indexes — price_indexes","text":"","code":"p0 <- price6[[2]] p1 <- price6[[3]] q0 <- quantity6[[2]] q1 <- quantity6[[3]] pb <- price6[[1]] qb <- quantity6[[1]]  #---- Calculating price indexes ----  # Most indexes can be calculated by combining the appropriate weights # with the correct type of mean  geometric_index(\"Laspeyres\")(p1, p0, q0) #> [1] 0.8705581 geometric_mean(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) #> [1] 0.8705581  # Arithmetic Laspeyres index  laspeyres_index(p1, p0, q0) #> [1] 0.9609929 arithmetic_mean(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) #> [1] 0.9609929  # Harmonic calculation for the arithmetic Laspeyres  harmonic_mean(p1 / p0, index_weights(\"HybridLaspeyres\")(p1, q0)) #> [1] 0.9609929  # Same as transmuting the weights  all.equal(   scale_weights(index_weights(\"HybridLaspeyres\")(p1, q0)),   transmute_weights(1, -1)(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) ) #> [1] TRUE  # This strategy can be used to make more exotic indexes, like the # quadratic-mean index (von der Lippe, 2007, p. 61)  generalized_mean(2)(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) #> [1] 1.020762  # Or the exponential mean index (p. 62)  log(arithmetic_mean(exp(p1 / p0), index_weights(\"Laspeyres\")(p0, q0))) #> [1] 1.013369  # Or the arithmetic hybrid index (von der Lippe, 2015, p. 5)  arithmetic_mean(p1 / p0, index_weights(\"HybridLaspeyres\")(p1, q0)) #> [1] 1.084248 contraharmonic_mean(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) #> [1] 1.084248  # Unlike its arithmetic counterpart, the geometric Laspeyres can # increase when base-period prices increase if some of these prices # are small  gl <- geometric_index(\"Laspeyres\") p0_small <- replace(p0, 1, p0[1] / 5) p0_dx <- replace(p0_small, 1, p0_small[1] + 0.01) gl(p1, p0_small, q0) < gl(p1, p0_dx, q0) #> [1] TRUE  #---- Price updating the weights in a price index ----  # Chain an index by price updating the weights  p2 <- price6[[4]] laspeyres_index(p2, p0, q0) #> [1] 0.970922  I1 <- laspeyres_index(p1, p0, q0) w_pu <- update_weights(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) I2 <- arithmetic_mean(p2 / p1, w_pu) I1 * I2 #> [1] 0.970922  # Works for other types of indexes, too  harmonic_index(\"Laspeyres\")(p2, p0, q0) #> [1] 0.5112654  I1 <- harmonic_index(\"Laspeyres\")(p1, p0, q0) w_pu <- factor_weights(-1)(p1 / p0, index_weights(\"Laspeyres\")(p0, q0)) I2 <- harmonic_mean(p2 / p1, w_pu) I1 * I2 #> [1] 0.5112654  #---- Percent-change contributions ----  # Percent-change contributions for the Tornqvist index  w <- index_weights(\"Tornqvist\")(p1, p0, q1, q0) (con <- geometric_contributions(p1 / p0, w)) #> [1] -0.01158644 -0.13847426  0.02391956 -0.02607786  0.09431814 -0.00896725  all.equal(sum(con), geometric_index(\"Tornqvist\")(p1, p0, q1, q0) - 1) #> [1] TRUE  #---- Missing values ----  # NAs get special treatment  p_na <- replace(p0, 6, NA)  # Drops the last price relative  laspeyres_index(p1, p_na, q0, na.rm = TRUE) #> [1] 0.9684288  # Only drops the last period-0 price  sum(p1 * q0, na.rm = TRUE) / sum(p_na * q0, na.rm = TRUE) #> [1] 0.9948605  #---- von Bortkiewicz decomposition ----  paasche_index(p1, p0, q1) / laspeyres_index(p1, p0, q0) - 1 #> [1] -0.04099992  wl <- scale_weights(index_weights(\"Laspeyres\")(p0, q0)) pl <- laspeyres_index(p1, p0, q0) ql <- quantity_index(laspeyres_index)(q1, q0, p0)  sum(wl * (p1 / p0 / pl - 1) * (q1 / q0 / ql - 1)) #> [1] -0.04099992  # Similar decomposition for geometric Laspeyres/Paasche  wp <- scale_weights(index_weights(\"Paasche\")(p1, q1)) gl <- geometric_index(\"Laspeyres\")(p1, p0, q0) gp <- geometric_index(\"Paasche\")(p1, p0, q1)  log(gp / gl) #> [1] 0.1388242  sum(scale_weights(wl) * (wp / wl - 1) * log(p1 / p0 / gl)) #> [1] 0.1388242  #---- Consistency in aggregation ----  p0a <- p0[1:3] p0b <- p0[4:6] p1a <- p1[1:3] p1b <- p1[4:6] q0a <- q0[1:3] q0b <- q0[4:6] q1a <- q1[1:3] q1b <- q1[4:6]  # Indexes based on the generalized mean with value share weights are # consistent in aggregation  lm_index(0.75)(p1, p0, q0) #> [1] 0.8962918  w <- index_weights(\"LloydMoulton\")(p0, q0) Ia <- generalized_mean(0.25)(p1a / p0a, w[1:3]) Ib <- generalized_mean(0.25)(p1b / p0b, w[4:6]) generalized_mean(0.25)(c(Ia, Ib), c(sum(w[1:3]), sum(w[4:6]))) #> [1] 0.8962918  # Agrees with group-wise indexes  all.equal(lm_index(0.75)(p1a, p0a, q0a), Ia) #> [1] TRUE all.equal(lm_index(0.75)(p1b, p0b, q0b), Ib) #> [1] TRUE  # Care is needed with more complex weights, e.g., Drobisch, as this # doesn't fit Balk's (2008) definition (p. 113) of a generalized-mean # index (it's the arithmetic mean of a Laspeyres and Paasche index)  arithmetic_index(\"Drobisch\")(p1, p0, q1, q0) #> [1] 0.9412926  w <- index_weights(\"Drobisch\")(p1, p0, q1, q0) Ia <- arithmetic_mean(p1a / p0a, w[1:3]) Ib <- arithmetic_mean(p1b / p0b, w[4:6]) arithmetic_mean(c(Ia, Ib), c(sum(w[1:3]), sum(w[4:6]))) #> [1] 0.9412926  # Does not agree with group-wise indexes  all.equal(arithmetic_index(\"Drobisch\")(p1a, p0a, q1a, q0a), Ia) #> [1] \"Mean relative difference: 0.000735017\" all.equal(arithmetic_index(\"Drobisch\")(p1b, p0b, q1b, q0b), Ib) #> [1] \"Mean relative difference: 0.0004652739\""},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantity index operator — quantity_index","title":"Quantity index operator — quantity_index","text":"Remaps price arguments quantity argument (vice versa) turn price index quantity index.","code":""},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantity index operator — quantity_index","text":"","code":"quantity_index(f)"},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantity index operator — quantity_index","text":"f price-index function.","code":""},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantity index operator — quantity_index","text":"function like f, except role prices/quantities reversed.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/quantity_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantity index operator — quantity_index","text":"","code":"p1 <- price6[[3]] p0 <- price6[[2]] q1 <- quantity6[[3]] q0 <- quantity6[[2]]  # Remap argument names to be quantities rather than prices  quantity_index(laspeyres_index)(q1 = q1, q0 = q0, p0 = p0) #> [1] 1.175887  laspeyres_index(p1 = q1, p0 = q0, q0 = p0) #> [1] 1.175887  # Works with the index_weights() functions, too  quantity_index(index_weights(\"Laspeyres\"))(q0 = q0, p0 = p0) #> [1] 0.96 2.70 2.47 0.91 6.58 0.48"},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale weights — scale_weights","title":"Scale weights — scale_weights","text":"Scale vector weights sum 1.","code":""},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale weights — scale_weights","text":"","code":"scale_weights(x)"},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale weights — scale_weights","text":"x strictly positive numeric vector.","code":""},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale weights — scale_weights","text":"numeric vector sums 1. NAs x result sums 1 values removed.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/scale_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale weights — scale_weights","text":"","code":"scale_weights(1:5) #> [1] 0.06666667 0.13333333 0.20000000 0.26666667 0.33333333"},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Splice an index series — splice_index","title":"Splice an index series — splice_index","text":"Splice collection index series computed rolling window one index series. Splicing multiple points combines results geometric mean.","code":""},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splice an index series — splice_index","text":"","code":"splice_index(x, periods = NULL, initial = NULL, published = FALSE)"},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splice an index series — splice_index","text":"x list equal-length numeric vectors giving period--period indexes window. periods integer vector giving splice points window. default splices point window. initial numeric vector giving initial period--period index series onto elements x spliced. default uses first element x. published splice done published series? default splices using recalculated index series.","code":""},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splice an index series — splice_index","text":"numeric vector giving spliced (fixed-base) index series.","code":""},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Splice an index series — splice_index","text":"Chessa, . G. (2019). Comparison Index Extension Methods Multilateral Methods. Paper presented 16th Meeting Ottawa Group Price Indices, 8-10 May 2019, Rio de Janeiro, Brazil. Krsinich, F. (2016). FEWS index: Fixed effects window splice. Journal Official Statistics, 32(2), 375-404.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/splice_index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splice an index series — splice_index","text":"","code":"# Make an index series over a rolling window x <- list(c(1.1, 0.9, 1.2), c(0.8, 1.3, 1.4), c(1.3, 1.3, 0.8))  # Mean splice  splice_index(x) #> [1] 1.100000 0.990000 1.188000 1.686819 1.284405  # Movement splice  splice_index(x, 3) #> [1] 1.10000 0.99000 1.18800 1.66320 1.33056  # Window splice  splice_index(x, 1) #> [1] 1.10000 0.99000 1.18800 1.60160 1.18976  # Splicing on the published series preserves the within-window # movement of the index series  splice_index(x, 1, published = TRUE) #> [1] 1.10000 0.99000 1.18800 1.60160 1.33848"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":null,"dir":"Reference","previous_headings":"","what":"Transmute weights — transmute_weights","title":"Transmute weights — transmute_weights","text":"Transmute weights turn generalized mean order \\(r\\) generalized mean order \\(s\\). Useful calculating additive multiplicative decompositions generalized-mean index, made nested generalized means (e.g., Fisher index).","code":""},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transmute weights — transmute_weights","text":"","code":"transmute_weights(r, s)  nested_transmute(r1, r2, s, t = c(1, 1))  nested_transmute2(r1, r2, s, t = c(1, 1))"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transmute weights — transmute_weights","text":"r, s finite number giving order generalized mean. See details. r1 finite number giving order outer generalized mean. r2 pair finite numbers giving order inner generalized means. t pair strictly positive weights inner generalized means. default equal weights.","code":""},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transmute weights — transmute_weights","text":"transmute_weights() returns function: nested_transmute() nested_transmute2() similarly return function:","code":"function(x, w = NULL){...} function(x, w1 = NULL, w2 = NULL){...}"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transmute weights — transmute_weights","text":"function transmute_weights(r, s) returns function compute vector weights v(x, w) nested_transmute(r1, r2, t, s) nested_transmute2(r1, r2, t, s) nested generalized means, generalizes result turning geometric mean arithmetic mean (vice versa) section 4.2 Balk (2008), Fisher mean arithmetic mean section 6 Reinsdorf et al. (2002), although usually important cases. See Martin (2021) details. nested_transmute2() takes slightly different approach nested_transmute(), generalizing van IJzeren arithmetic decomposition Fisher index (Balk, 2008, section 4.2.2) using approach Martin (2021), although cases results broadly similar. Transmuting weights returns value length x, missing values x weights return NA. Unless values NA, however, result still satisfy identities na.rm = TRUE.","code":"generalized_mean(r)(x, w) == generalized_mean(s)(x, v(x, w)) nested_mean(r1, r2, t)(x, w1, w2) ==   generalized_mean(s)(x, v(x, w1, w2))"},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Transmute weights — transmute_weights","text":"Balk, B. M. (2008). Price Quantity Index Numbers. Cambridge University Press. Martin, S. (2021). note general decompositions price indexes. Prices Analytical Series, Statistics Canada catalogue . 62F0014M. Statistics Canada, Ottawa. Reinsdorf, M. B., Diewert, W. E., Ehemann, C. (2002). Additive decompositions Fisher, Törnqvist geometric mean indexes. Journal Economic Social Measurement, 28(1-2):51–61. Sydsaeter, K., Strom, ., Berck, P. (2005). Economists' Mathematical Manual (4th edition). Springer.","code":""},{"path":[]},{"path":"https://marberts.github.io/gpindex/reference/transmute_weights.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transmute weights — transmute_weights","text":"","code":"x <- 1:3 y <- 4:6 w <- 3:1  #---- Transforming generalized means ----  # Calculate the geometric mean as an arithmetic mean and # harmonic mean by transmuting the weights  geometric_mean(x) #> [1] 1.817121 arithmetic_mean(x, transmute_weights(0, 1)(x)) #> [1] 1.817121 harmonic_mean(x, transmute_weights(0, -1)(x)) #> [1] 1.817121  # Transmuting the weights for a harmonic mean into those # for an arithmetic mean is the same as using weights w / x  all.equal(transmute_weights(-1, 1)(x, w), scale_weights(w / x)) #> [1] TRUE  # Transmuting the weights for an arithmetic mean into those # for a harmonic mean is the same as using weights w * x  all.equal(transmute_weights(1, -1)(x, w), scale_weights(w * x)) #> [1] TRUE  # Works for nested means, too  w1 <- 3:1 w2 <- 1:3  fisher_mean(x, w1, w2) #> [1] 1.825742  arithmetic_mean(x, nested_transmute(0, c(1, -1), 1)(x, w1, w2)) #> [1] 1.825742 arithmetic_mean(x, nested_transmute2(0, c(1, -1), 1)(x, w1, w2)) #> [1] 1.825742  # Note that nested_transmute() has an invariance property # not shared by nested_transmute2()  all.equal(   nested_transmute(0, c(1, -1), 1)(x, w1, w2),   transmute_weights(2, 1)(     x, nested_transmute(0, c(1, -1), 2)(x, w1, w2)   ) ) #> [1] TRUE  all.equal(   nested_transmute2(0, c(1, -1), 1)(x, w1, w2),   transmute_weights(2, 1)(     x, nested_transmute2(0, c(1, -1), 2)(x, w1, w2)   ) ) #> [1] \"Mean relative difference: 0.0015427\"  #---- Monotonicity ----  # Transmuted weights increase when x is small and decrease # when x is large if r < s  transmute_weights(0, 1)(x, w) > scale_weights(w) #> [1]  TRUE FALSE FALSE  # The opposite happens when r > s  transmute_weights(1, 0)(x, w) > scale_weights(w) #> [1] FALSE  TRUE  TRUE  #---- Percent-change contributions ----  # Transmuted weights can be used to calculate percent-change # contributions for, e.g., a geometric price index  transmute_weights(0, 1)(x) * (x - 1) #> [1] 0.0000000 0.3122793 0.5048413 geometric_contributions(x) # the more convenient way #> [1] 0.0000000 0.3122793 0.5048413  #---- Basket representation of a price index ----  # Any generalized-mean index can be represented as a basket-style # index by transmuting the weights, which is how some authors # define a price index (e.g., Sydsaeter et al., 2005, p. 174)  p1 <- 2:6 p0 <- 1:5  qs <- transmute_weights(-1, 1)(p1 / p0) / p0 all.equal(harmonic_mean(p1 / p0), sum(p1 * qs) / sum(p0 * qs)) #> [1] TRUE"},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-063","dir":"Changelog","previous_headings":"","what":"Version 0.6.3","title":"Version 0.6.3","text":"Bumped minimum version R >= 4.1. geks() now faster uses less memeory makes GEKS index.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-062","dir":"Changelog","previous_headings":"","what":"Version 0.6.2","title":"Version 0.6.2","text":"CRAN release: 2024-08-16 splice_index() now keeps names. Fixed bug transmute_weights() weights negative. Price-index functions better argument checking.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-061","dir":"Changelog","previous_headings":"","what":"Version 0.6.1","title":"Version 0.6.1","text":"CRAN release: 2024-04-12 Updated maintainer email. Added parameter generalize geks() controlling indexes averaged rolling window. Fixed bug transmute_weights() factor_weights() return result different length w. Added new function splice_index() splicing indexes calculated rolling window (previously sketched example). transmute_weights() now faster.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-060","dir":"Changelog","previous_headings":"","what":"Version 0.6.0","title":"Version 0.6.0","text":"CRAN release: 2023-11-15 Bumped minimum version R least 4.0. use ... grouped() balanced() deprecated, removed future version. behavior can using anonymous function. Added walsh_geks() function. back_period() base_period() gain new argument match_first control whether products first period match return NA. Updated documentation. Added brief vignette.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-050","dir":"Changelog","previous_headings":"","what":"Version 0.5.0","title":"Version 0.5.0","text":"CRAN release: 2023-08-08 back_price() base_price() removed. Functions transforming weights keep attributes weights (), documented. grouped() longer mangles names.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-043","dir":"Changelog","previous_headings":"","what":"Version 0.4.3","title":"Version 0.4.3","text":"CRAN release: 2022-05-01 back_price() base_price() deprecated favor general back_period() base_period() functions. removed future version. algorithm making GEKS indexes now much faster rolling window.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-042","dir":"Changelog","previous_headings":"","what":"Version 0.4.2","title":"Version 0.4.2","text":"CRAN release: 2022-01-26 functions overall structure package fairly stable now . Added nested_transmute() nested_transmute2() transmuting weights nested generalized means. consistent argument names, first two arguments nested_mean() nested_contributions*() now r1 r2. Added geometric Theil Rao indexes.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-039","dir":"Changelog","previous_headings":"","what":"Version 0.3.9","title":"Version 0.3.9","text":"CRAN release: 2021-11-26 Added back_period() base_period(), general back_price() base_price(). Added lehr_index(). Fixed rare warning sqrt() making NaNs generalized_logmean(-1) inputs close equal, despite NaNs showing result. lm_index() *_agmean_index() functions now function factories.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-036","dir":"Changelog","previous_headings":"","what":"Version 0.3.6","title":"Version 0.3.6","text":"CRAN release: 2021-10-02 Added balanced() operator make easier remove NAs price index functions. Added geks() function using price-index function (e.g., fisher_index()) makes GEKS index.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-034","dir":"Changelog","previous_headings":"","what":"Version 0.3.4","title":"Version 0.3.4","text":"CRAN release: 2021-08-04 Added French translations. Made number optimizations make results generalized_mean(), extended_mean(), lehmer_mean(), transmute_weights(), factor_weights() faster common cases. Added grouped() operator make functions work grouped data.","code":""},{"path":"https://marberts.github.io/gpindex/news/index.html","id":"version-031","dir":"Changelog","previous_headings":"","what":"Version 0.3.1","title":"Version 0.3.1","text":"CRAN release: 2021-07-07 function names changed less awkward; e.g., mean_generalized() now generalized_mean(), contributions_geometric() now geometric_contributions(). unfortunately backwards compatible, needed done. Added nested_mean() function calculate nested generalized means , e.g., Fisher index. interface nested_contributions() now much simpler, function focused making contributions Fisher indexes. Added nested_contributions2() function implements different algorithm. Added arithmetic_agmean_index() geometric_agmean_index() functions calculate AG mean index. Added functions standard outlier-detection methods price relatives. Dropped scale argument generalized_mean(), really wasn’t needed potential make problems solved.","code":""}]
